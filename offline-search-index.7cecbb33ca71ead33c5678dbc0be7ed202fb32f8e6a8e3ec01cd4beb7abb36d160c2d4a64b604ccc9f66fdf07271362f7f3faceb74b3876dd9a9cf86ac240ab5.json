[{"body":"FHIR Shorthand (“FSH” or “Shorthand”) is a specially-designed language for defining the content of Health Level Seven (HL7®) Fast Healthcare Interoperability Resources (FHIR®) Implementation Guides (IGs). It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and IGs.\nSUSHI (“SUSHI Unshortens ShortHand Inputs”) is a reference implementation of an interpreter/compiler for the FSH language. SUSHI produces FHIR profiles, extensions, and other artifacts needed to create FHIR Implementation Guides (IG).\nFSH School Conventions The following style conventions are used throughout the FSH School content:\n   Style Explanation Example     Code Code fragments, such as commands, FSH statements, and syntax expressions * status = #open   {curly braces} An item to be substituted in a syntax expression {display string}   \u003cdatatype\u003e An element or path to an element with the given data type, to be substituted in the syntax expression \u003cCodeableConcept\u003e   italics An optional item in a syntax expression ”{string}“   ellipsis (…) Indicates a pattern that can be repeated {flag1} {flag2} {flag3} …   bold A directory path or file name example-1.fsh    In addition, the following symbols are used in documented commands:\n   Symbol Explanation      Indicates information or command specific to OS X. Commands can be run within the Terminal application.    Indicates information or command specific to Windows. A command window can be launched by typing cmd at the Search Windows tool.    Represents command prompt (may vary depending on platform)    Understanding FHIR Shorthand Some sections of FSH School assume a basic understanding of FHIR Shorthand. You can access the FHIR Shorthand documentation at any time by clicking the “FHIR Shorthand” link in the left-hand column.\nWe recommend new FSH authors start with the overview and review the language reference when additional details are needed.\nUnderstanding FHIR Profiling Most FSH School resources assume a basic understanding of FHIR and FHIR profiling. You can access the FHIR documentation at any time by clicking the “FHIR R4” link in the left-hand column. You may find the following more specific links helpful as well:\n Profiling: Provides information and guidance on profiling topics such as constraining and slicing. Extensibility: Provides information about using and defining extensions. Resources: Lists all FHIR resources. Useful for referencing available elements as you write profiles. DataTypes: Lists all FHIR datatypes. Useful for understanding types declared in resource elements. StructureDefinition: Documents StructureDefinition (basis for resources, profiles, and extensions). Useful for authoring top-level caret rules. ElementDefinition: Documents ElementDefinition (basis for elements in resources, profile, and extensions). Useful for authoring path-specific caret rules. Guidance for FHIR IG Creation: (Work in Progress) Documents the new template-based publishing framework. IG Publisher: Documents how to use and configure the HL7 IG Publisher.  ","excerpt":"FHIR Shorthand (“FSH” or “Shorthand”) is a specially-designed language …","ref":"/docs/introduction/","title":"Introduction"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  Step 1: Install Node.js SUSHI requires Node.js. To install Node.js, go to https://nodejs.org/ and select the “LTS” download. If the download is not appropriate for your operating system, click the “Other Downloads” link to get a full list of downloads. Once the installer is downloaded, run it using the default options.\nEnsure that Node.js is correctly installed by opening a command window and typing the following two commands. Each command should return a version number.\n node --version  npm --version Step 2: Install SUSHI To install SUSHI, open up a command prompt and type the following command:\n npm install -g fsh-sushi Check the installation via the command below:\n sushi -h If the command outputs instructions on using the SUSHI command line interface (CLI), you’re ready to run SUSHI.\nUse sushi -v to display the installed version of SUSHI and the version of the FSH specification it supports. SUSHI follows the semantic versioning convention (MAJOR.MINOR.PATCH):\n MAJOR: A major release has significant new functionality and, potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatibility within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatibility within the major version.  Tip For the most up-to-date information and latest releases of SUSHI, check the release history and release notes.  Updating or Reverting SUSHI To update SUSHI to the latest version, re-run:\n npm install -g fsh-sushi To revert to a previous version of SUSHI, run:\n npm install -g fsh-sushi@{version} where the {version} is replaced by the desired MAJOR.MINOR.PATCH version (e.g., npm install -g fsh-sushi@0.14.0).\n","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/sushi/installation/","title":"Installation"},{"body":"Step 1: Install Node.js GoFSH requires Node.js. To install Node.js, go to https://nodejs.org/ and select the “LTS” download. If the download is not appropriate for your operating system, click the “Other Downloads” link to get a full list of downloads. Once the installer is downloaded, run it using the default options.\nEnsure that Node.js is correctly installed by opening a command window and typing the following two commands. Each command should return a version number.\n node --version  npm --version Step 2: Install GoFSH To install GoFSH, open up a command prompt and type the following command:\n npm install -g gofsh Check the installation via the command below:\n gofsh --help If the command outputs instructions on using the GoFSH command line interface (CLI), you’re ready to run GoFSH.\nUse gofsh -v to display the installed version of GoFSH and the version of the FSH specification it supports. GoFSH follows the semantic versioning convention (MAJOR.MINOR.PATCH):\n MAJOR: A major release has significant new functionality and, potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatibility within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatibility within the major version.  Updating or Reverting GoFSH To update GoFSH to the latest version, re-run:\n npm install -g gofsh To revert to a previous version of GoFSH, run:\n npm install -g gofsh@{version} where the {version} is replaced by the desired MAJOR.MINOR.PATCH version (e.g., npm install -g gofsh@0.1.0).\n","excerpt":"Step 1: Install Node.js GoFSH requires Node.js. To install Node.js, go …","ref":"/docs/gofsh/installation/","title":"Installation"},{"body":"Step 1: Install Node.js SUSHI requires Node.js. To install Node.js, go to https://nodejs.org/ and select the “LTS” download. If the download is not appropriate for your operating system, click the “Other Downloads” link to get a full list of downloads. Once the installer is downloaded, run it using the default options.\nEnsure that Node.js is correctly installed by opening a command window and typing the following two commands. Each command should return a version number.\n node --version  npm --version Step 2: Install SUSHI To install SUSHI, open up a command prompt and type the following command:\n npm install -g fsh-sushi Check the installation via the command below:\n sushi -h If the command outputs instructions on using the SUSHI command line interface (CLI), you’re ready to run SUSHI.\nUse sushi -v to display the installed version of SUSHI and the version of the FSH specification it supports. SUSHI follows the semantic versioning convention (MAJOR.MINOR.PATCH):\n MAJOR: A major release has significant new functionality and, potentially, grammar changes or other non-backward-compatible changes. MINOR: Contains new or modified features, while maintaining backwards compatibility within the major version. PATCH: Contains minor updates and bug fixes, while maintaining backwards compatibility within the major version.  Tip For the most up-to-date information and latest releases of SUSHI, check the release history and release notes.  Reverting SUSHI To revert to a previous version of SUSHI, run:\n npm install -g fsh-sushi@{version} where the {version} is replaced by the desired MAJOR.MINOR.PATCH version (e.g., npm install -g fsh-sushi@0.16.0).\n","excerpt":"Step 1: Install Node.js SUSHI requires Node.js. To install Node.js, go …","ref":"/docs/sushi/installation/","title":"Installation"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  FHIR Shorthand (“FSH” or “Shorthand”) is a specially-designed language for defining the content of Health Level Seven (HL7®) Fast Healthcare Interoperability Resources (FHIR®) Implementation Guides (IGs). It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and IGs.\nSUSHI (“SUSHI Unshortens ShortHand Inputs”) is a reference implementation of an interpreter/compiler for the FSH language. SUSHI produces FHIR profiles, extensions, and other artifacts needed to create FHIR Implementation Guides (IG).\nFSH School Conventions The following style conventions are used throughout the FSH School content:\n   Style Explanation Example     Code Code fragments, such as commands, FSH statements, and syntax expressions * status = #open   {curly braces} An item to be substituted in a syntax expression {display string}   \u003cdatatype\u003e An element or path to an element with the given data type, to be substituted in the syntax expression \u003cCodeableConcept\u003e   italics An optional item in a syntax expression ”{string}“   ellipsis (…) Indicates a pattern that can be repeated {flag1} {flag2} {flag3} …   bold A directory path or file name example-1.fsh    In addition, the following symbols are used in documented commands:\n   Symbol Explanation      Indicates information or command specific to OS X. Commands can be run within the Terminal application.    Indicates information or command specific to Windows. A command window can be launched by typing cmd at the Search Windows tool.    Represents command prompt (may vary depending on platform)    Understanding FHIR Shorthand Some sections of FSH School assume a basic understanding of FHIR Shorthand. You can access the FHIR Shorthand documentation at any time by clicking the “FHIR Shorthand” link in the left-hand column.\nWe recommend new FSH authors start with the overview and review the language reference when additional details are needed.\nUnderstanding FHIR Profiling Most FSH School resources assume a basic understanding of FHIR and FHIR profiling. You can access the FHIR documentation at any time by clicking the “FHIR R4” link in the left-hand column. You may find the following more specific links helpful as well:\n Profiling: Provides information and guidance on profiling topics such as constraining and slicing. Extensibility: Provides information about using and defining extensions. Resources: Lists all FHIR resources. Useful for referencing available elements as you write profiles. DataTypes: Lists all FHIR datatypes. Useful for understanding types declared in resource elements. StructureDefinition: Documents StructureDefinition (basis for resources, profiles, and extensions). Useful for authoring top-level caret rules. ElementDefinition: Documents ElementDefinition (basis for elements in resources, profile, and extensions). Useful for authoring path-specific caret rules. Guidance for FHIR IG Creation: (Work in Progress) Documents the new template-based publishing framework. IG Publisher: Documents how to use and configure the HL7 IG Publisher.  ","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/introduction/","title":"Introduction"},{"body":"This section several tutorials that will walk you through the process of using FSH to make a FHIR Implementation Guide.\n","excerpt":"This section several tutorials that will walk you through the process …","ref":"/docs/tutorials/","title":"Tutorials"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  FHIR Shorthand (FSH) is a specially-designed language for defining the content of FHIR Implementation Guides (IGs). It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and IGs. FSH is compiled from text files to FHIR artifacts using SUSHI. To get started using FSH, you need to install and run SUSHI using the steps below.\nStep 1: Review Introduction If you haven’t done so already, please read or review the Introduction documentation to gain an understanding of the conventions used in this tutorial and the resources available to you.\nStep 2: Install Node.js and Sushi If you have not already installed SUSHI, follow the SUSHI Installation instructions.\nStep 3: Download Sample FSH Tank To start with some working examples of FSH files and a skeleton FSH tank,  download the FSH Tutorial Starter and unzip it into a directory of your choice.\nAfter the file is unzipped, you should see two subdirectories:\n FishExample FishExampleComplete  Change the working directory to FishExample. There are two FSH files:\n FishPatient.fsh Veterinarian.fsh  In addition, there is a config.yaml file and a subdirectory, /ig-data, containing some inputs for building the IG.\nStep 4: Run SUSHI Now that you have SUSHI installed and a minimal FSH tank, open up a command window, and navigate to the FishExample directory. Run SUSHI on those FSH files by executing:\n sushi .  Note The dot (.) represents “this directory,” the location of the FSH files. You can also specify the location explicitly by replacing the dot with a directory path.  Running SUSHI will create a FishExample/build/input/resources directory, and populate it with the files needed to create the IG using the HL7 FHIR IG Publisher tool.\nWhile running SUSHI, there will be a series of informational message. When SUSHI completes, you should see a summary output similar this:\n╔════════════════════════ SUSHI RESULTS ══════════════════════════╗ ║ ╭──────────┬────────────┬───────────┬─────────────┬───────────╮ ║ ║ │ Profiles │ Extensions │ ValueSets │ CodeSystems │ Instances │ ║ ║ ├──────────┼────────────┼───────────┼─────────────┼───────────┤ ║ ║ │ 2 │ 0 │ 0 │ 0 │ 0 │ ║ ║ ╰──────────┴────────────┴───────────┴─────────────┴───────────╯ ║ ║ ║ ║ See SUSHI-GENERATED-FILES.md for details on generated IG files. ║ ╠═════════════════════════════════════════════════════════════════╣ ║ Nice! You're totally krilling it! 0 Errors 0 Warnings ║ ╚═════════════════════════════════════════════════════════════════╝ The files generated by SUSHI are located in the FishExample/build directory. Check that the build/input/profiles subdirectory contains two generated StructureDefinitions.\nStep 5: Generate the Sample IG Now change working directory of the command window to the build directory. At the command prompt, enter:\n  _updatePublisher   ./_updatePublisher.sh This will download the latest version of the HL7 FHIR IG Publisher tool into ./build/input-cache. This step can be skipped if you already have run the command recently, and have the latest version of the IG Publisher tool.\nTip If you are blocked by a firewall, or if for any reason _updatePublisher fails to execute, download the current IG Publisher jar file here. When the file has downloaded, move it into the directory /FishExample/build/input-cache (creating the directory if necessary).  Warning Before proceeding to the next command: If you have never run the IG Publisher, you may need to install Jekyll first. See Installing the IG Publisher for details.  Now run:\n  _genonce   ./_genonce.sh This will run the HL7 FHIR IG generator, which may take several minutes to complete.\nAfter the publisher is finished, open the file /FishExample/build/output/index.html to see the resulting IG.\nIf you click on the Artifacts Summary item in the menu, you will see that the IG contains two profiles, FishPatient and Veterinarian. If you look at each of them, you will notice that they have minimal differentials. The only way in which they differ from their base resource is that they require at least one name.\nStep 6: Setting Cardinalities in a Profile It is not widely known, but FHIR is designed to be used for veterinary medicine as well as human. For a non-human patient, we need to record the species. The Patients in this Tutorial are going to be various species of fish 🐟.\nSince fish don’t get legally married (although some species do pair bond) and they don’t communicate in a human language, the first thing we’ll do in the FishPatient profile is eliminate these elements. To do this, open the file FishPatient.fsh in your favorite plain-text editor, and add the following rules after the last non-blank line in the file:\n* maritalStatus 0..0 * communication 0..0 Note that rules start with *. FSH expresses cardinality as, {min}..{max}, the same as FHIR.\nStep 7: Create a Species Extension for FishPatient To specify the species of our aquatic patients, we’ll need an extension.\nWe have a choice of whether to make the extension inline or standalone. Inline extensions do not result in a separate StructureDefinition, and cannot be reused in other profiles. Standalone extensions are the opposite: they have independent StructureDefinitions, and can be reused. For this example, let’s make a standalone extension.\nExtensions are created using the contains keyword. To add a standalone species extension, add the following rule after the cardinality rules:\n* extension contains FishSpecies named species 0..1 This rule states that the extension array of the Patient resource will incorporate the FishSpecies extension with the local name species.\nTo define the FishSpecies extension, add the following lines to the end of the FishPatient.fsh file:\nExtension: FishSpecies Id: fish-species Title: \"Fish Species\" Description: \"The species of the fish.\"  Tip FSH ignores extra whitespace, so authors can choose to use whitespace for improved visual alignment, as in the extension definition above.  Run SUSHI again (sushi .). The count of Extensions should now be 1.\nStep 8: Define a Value Set for Fish Species The FishSpecies extension doesn’t quite do its job yet, because we haven’t specified what type of values it might accept. To add this information, enter these lines following the description of FishSpecies:\n* value[x] only CodeableConcept * valueCodeableConcept from FishSpeciesValueSet (extensible) The first rule restricts the value[x] (a built-in element of every FHIR extension) to a CodeableConcept using the only keyword. The second binds it to a value set (yet to be defined) using the from keyword. The binding strength will be extensible, meaning the codes in the FishSpeciesValueSet must be used except when the value set is missing a specific fish species.\nTo define FishSpeciesValueSet, add the following lines to the same file:\nValueSet: FishSpeciesValueSet Title: \"Fish Species Value Set\" Id: fish-species-value-set Description: \"Codes describing various species of fish, taken from SNOMED-CT.\" * codes from system http://snomed.info/sct where concept is-a SCT#90580008 \"Fish (organism)\"  Info The rule in the value set definition above selects all codes from SNOMED-CT that are children of the concept “Fish (organism)”.  Run SUSHI again. The count of ValueSets should now be 1. Try generating the IG by changing directories to build and running _genonce again. Open the file /FishExample/build/output/index.html to see the resulting IG.\n Do you see where the FishPatient profile is in the IG? Does the differential reflect your changes? How does FHIR render the value set you defined?  Step 9: Define an Alias An Alias is a way to define a shorthand for a URL or OID. For example, in the value set definition above, we could have defined an Alias to make referencing the http://snomed.info/sct URL easier, as shown below. Aliases are conventionally defined at the top of the file.\nAdd this line at the top of the FishPatient.fsh file:\nAlias: SCT = http://snomed.info/sct and then replace the last line in the FishSpeciesValueSet with:\n* codes from system SCT where concept is-a #90580008 \"Fish (organism)\"  Tip Using aliases has no effect on the IG; it simply makes the FSH code a bit neater.  Step 10: Create an Instance of FishPatient Every IG should provide examples of its profiles. Let’s do that by introducing an example FishPatient named Shorty. Create this example instance using the Instance keyword, with InstanceOf set to FishPatient and Usage set to Example.\nInclude the following information about Shorty in the instance:\n His given (first) name is “Shorty” and his family (last) name is “Koi-Fish”. Shorty is a Koi fish (Cyprinus rubrofuscus), represented as SNOMED-CT code 47978005 “Carpiodes cyprinus (organism)”.  If you need help with this, you can reference the Defining Instances section of the specification. If you still need help, you can peek at the FSH files in the FishExampleComplete directory.\nRun SUSHI again, and re-generate the IG.\n Did it compile without errors? What does the IG look like now?  Step 11: Extend the Veterinarian Profile Now, add constraints and/or extensions to the Veterinarian profile:\n  Add qualifications consistent with a Veterinary practice. Qualifications are taken from code system http://nucc.org/provider-taxonomy, and the code is 174M00000X, for “Veterinarian”.\n  In addition, slice the identifier array, making a license number required. The code system is http://terminology.hl7.org/CodeSystem/v2-0203 and the code is LN, for “License number”.\n  If you need help with this, you can refer to the assignment rules and slicing rules sections of the specification. If you still need help, you can peek at the FSH files in the FishExampleComplete directory.\nRun SUSHI again, and re-generate the IG.\n Did it compile without errors? What does the IG look like now?  Congratulations! You’ve completed the FSH tutorial. It might be time to feast on some sushi!\n","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/tutorials/basic/","title":"Basic SUSHI Tutorial"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  Simple FSH Projects The simplest FSH project (sometimes referred to as a “FSH tank”) contains only a configuration file and FSH files containing FHIR Shorthand definitions. For example, a simple FSH tank might look like this:\nsimple-project ├── config.yaml ├── file1.fsh ├── file2.fsh └── file3.fsh The config.yaml file provides project configuration data to SUSHI. It is described further in the Configuration documentation.\nEach FSH file can contain multiple FSH definitions of varying types. FSH file names are not significant, but must end with the .fsh extension. In addition, FSH files can be organized into subdirectories. This provides authors the flexibility to organize their FSH definitions in whatever way makes sense to then.\nTip A simple FSH project like the one shown above can be used with a minimal config.yaml file to create a bare-bones IG . It can also be used to generate only the FHIR resources by specifying the FSHOnly flag in config.yaml. Most authors who want to develop an IG using SUSHI, however, will also use an ig-data directory. Continue reading for more details.  Using a fsh Subdirectory with the HL7 IG Publisher and Auto-Builder If a project is intended to be built by the HL7 IG Publisher Auto-Builder, the FSH tank should be located in a fsh subdirectory:\nsimple-ig └── fsh ├── config.yaml ├── file1.fsh ├── file2.fsh └── file3.fsh When the IG Publisher detects a fsh subdirectory, it will automatically run SUSHI on that directory and output the SUSHI results to the parent of the fsh subdirectory (e.g., the simple-ig directory in the example above). It will then continue with the normal IG Publisher process.\nThis approach allows a GitHub repository to be configured such that whenever changes to FSH files are pushed to GitHub, the Auto-Builder will pick them up, run the SUSHI/IG Publisher process, and publish the resulting IG to http://build.fhir.org.\nNote Using a fsh subdirectory is not required, but since many authors prefer this option, the remaining documentation assumes a fsh subdirectory in its file structures.  IG Projects SUSHI provides support for many of the files and directories required by the template-based IG Publisher for building Implementation Guides. Many IG customizations can be configured using additional properties in the config.yaml file.\nAdditionally, authors can create and populate the ig-data directory with custom content for package-list.json, ig.ini, menu.xml, index.md (or index.xml), pages, images, and other IG Publisher inputs. For example, a FSH project for a customized IG might look like this:\ncustomized-ig └── fsh ├── config.yaml ├── file1.fsh ├── file2.fsh ├── file3.fsh └── ig-data ├── ig.ini ├── input │ ├── ignoreWarnings.txt │ ├── images │ │ ├── myDocument.pdf │ │ ├── myGraphic.png │ │ └── mySpreadsheet.xlsx │ ├── includes │ │ └── menu.xml │ └── pagecontent │ ├── 1_mySecondPage.md │ ├── 2_myThirdPage.md │ ├── 3_myFourthPage.md │ └── index.md └── package-list.json You can populate your project (under fsh above) as follows:\n config.yaml: This required file provides project configuration data to SUSHI. It is described further in the Configuration documentation. *.fsh: FSH files contain the FHIR Shorthand definitions for all the resources and examples in your IG. ig-data/ig.ini: If present and no template property is specified in config.yaml, the user-provided file will be used instead of a generated one. ig-data/input/ignoreWarnings.txt: If present, this file can be used to suppress specific QA warnings and information messages during the FHIR IG publication process. ig-data/input/images/*: Put anything that is not a page in the IG, such as images, spreadsheets or zip files, in the ig-data/input/images subdirectory. These files will be copied into the build and can be referenced by user-provided pages or menus. ig-data/input/includes/menu.xml: If present and no menu property is specified in config.yaml, this file will be used for the IG’s main menu layout. ig-data/input/pagecontent/*: Put either markup (.xml) or markdown (.md) files with the narrative content of your IG in the ig-data/input/pagecontent/ subdirectory. These files are the sources for the html pages that accompany the automatically-generated pages of your IG. The header and footer of these pages are automatically generated, so your content should not include these elements. Any number of pages can be added. In addition to stand-alone pages, you can provide additional text for generated artifact pages. The naming of these files is significant:  index.xml|md: This file provides the content for the IG’s main page, unless the indexPageContent property is specified in config.yaml, in which case this file should not exist. Providing an index file is strongly recommended over inlining the content in config.yaml. N_pagename.xml|md: If present, these files will be generated as individual pages in the IG. The leading integer (N) determines the order of the pages in the table of contents. These numbers are stripped and do not appear in the actual page URLs. {artifact-file-name}-intro.xml|md: If present, the contents of the file will be placed on the relevant page before the artifact’s definition. {artifact-file-name}-notes.xml|md: If present, the contents of the file will be placed on the relevant page after the artifact’s definition.   ig-data/input/{supported-resource-input-directory}/* (not shown above): JSON or XML files in supported resource directories (e.g., profiles, extensions, examples, etc.) will be be copied to the corresponding locations in the IG input and processed as additional (non-FSH) IG resources. This feature is not expected to be commonly used. ig-data/package-list.json: This optional file, described here, should contain the version history of your IG. If present and no history property is specified in config.yaml, it will be used instead of a generated package-list.json.  Tip Examples of package.json, ig.ini, package-list.json, ignoreWarnings.txt and menu.xml files can be found in the sample IG project provided for this purpose. In addition, more general guidance can be found in Guidance for HL7 IG Creation. For a real-world example of a populated ig-data directory, see the mCODE Implementation Guide.  Initializing a SUSHI Project Setting up this project structure manually can be complex, so to simplify that process, SUSHI provides an --init option. Running sushi --init will cause SUSHI to create a new SUSHI project with a default configuration and project structure. This provides a simple way to get started with FHIR Shorthand and SUSHI.\nWhen sushi --init is run, SUSHI will request high-level project information from the user:\nName (Default: ExampleIG): NewIG Id (Default: fhir.example): my.id Canonical (Default: http://example.org): http://myid.org Status (Default: draft): active Version (Default: 0.1.0): 2.0.0 Initialize SUSHI project in C:\\Users\\shorty\\dev\\NewIG? [y/n]: y These values are used to generate a simple config.yaml file and a corresponding IG-Publisher-compatible project structure:\nNewIG ├── .gitignore ├── _genonce.bat ├── _genonce.sh ├── _updatePublisher.bat ├── _updatePublisher.sh ├── _gencontinuous.bat ├── _gencontinuous.sh └── fsh ├── config.yaml ├── ig-data │ └── input │ └── pagecontent │ └── index.md └── patient.fsh In addition to the contents of the fsh folder, --init adds several .bat and .sh scripts which allow you to run the IG Publisher, and a default .gitignore file for a FSH project. From this point on, the author can modify the configuration and definitions as necessary.\n","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/sushi/project/","title":"Project Structure"},{"body":"Simple FSH Projects The simplest FSH project (sometimes referred to as a “FSH tank”) contains only a configuration file and an input/fsh subdirectory of FSH files containing FHIR Shorthand definitions. For example, a simple FSH tank might look like this:\nsimple-project ├── input | └── fsh | ├── file1.fsh | ├── file2.fsh | └── file3.fsh └── sushi-config.yaml The sushi-config.yaml file provides project configuration data to SUSHI. It is described further in the Configuration documentation.\nEach FSH file can contain multiple FSH definitions of varying types. FSH file names are not significant, but must end with the .fsh extension. In addition, FSH files can be organized into subdirectories. This provides authors the flexibility to organize their FSH definitions in whatever way makes sense to then.\nIgnoring Warnings SUSHI may log warnings based on the content of the project, which can be ignored with an optional sushi-ignoreWarnings.txt file. Note that the contents of this file can only be used to ignore warnings. Errors and informational logs from SUSHI cannot be ignored. This file should be placed either at the root of the project (e.g., simple-project/sushi-ignoreWarnings.txt in the example above), or within the input directory (e.g., simple-project/input/sushi-ignoreWarnings.txt). Each line in the sushi-ignoreWarnings.txt file specifies warnings to ignore. Warnings will be ignored if they completely match the contents of any line in the sushi-ignoreWarnings.txt file. The warning to ignore must be specified on only one line, and the match is case-sensitive. Additionally, regular expressions can be specified in the sushi-ignoreWarnings.txt file. Each regular expression must be on only one line, and a regular expression is indicated by starting and ending the line with /. For example, if the sushi-ignoreWarnings.txt file was as follows:\nInstance PatientExample1 is not an instance of a resource, so it should only be used inline on other instances, and it will not be exported to a standalone file. Specify \"Usage: #inline\" to remove this warning. /Detected the following non-conformant Resource definitions.*/ Then any warning which exactly matches the contents of the first line will be ignored, and any warning which starts with the text Detected the following non-conformant Resource definitions will be ignored.\nTip SUSHI does log several multi-line warnings, but these warnings cannot be specified directly in the sushi-ignoreWarnings.txt file, since the warnings to ignore must be specified line by line. To ignore these warnings, a regular expression should be used.  Using the HL7 IG Publisher and Auto-Builder This project structure integrates with the HL7 IG Publisher Auto-Builder. When the IG Publisher detects an input/fsh subdirectory, it will automatically run SUSHI on the project directory and output the SUSHI results to a fsh-generated directory (e.g., simple-project/fsh-generated in the example above). It will then continue with the normal IG Publisher process.\nThis approach allows a GitHub repository to be configured such that whenever changes to FSH files are pushed to GitHub, the Auto-Builder will pick them up, run the SUSHI/IG Publisher process, and publish the resulting IG to http://build.fhir.org.\nIG Projects Warning As of the SUSHI 1.0 release, the ig.ini MUST use a template based on fhir.base.template#current. See the detailed description of ig.ini below for a more in depth list of allowed templates.  SUSHI provides support for several of the files and directories required by the template-based IG Publisher for building Implementation Guides. Some IG customizations can be configured using additional properties in the sushi-config.yaml file. A FSH project integrated into the template-based IG Publisher may look like this:\ncustomized-ig ├── ig.ini ├── input | ├── fsh | | ├── file1.fsh | | ├── file2.fsh | | └── file3.fsh │ ├── ignoreWarnings.txt │ ├── images │ │ ├── myDocument.pdf │ │ ├── myGraphic.png │ │ └── mySpreadsheet.xlsx │ ├── includes │ │ └── menu.xml │ └── pagecontent │ ├── 1_mySecondPage.md │ ├── 2_myThirdPage.md │ ├── 3_myFourthPage.md │ └── index.md ├── package-list.json ├── sushi-ignoreWarnings.txt └── sushi-config.yaml You can populate your project as follows:\n sushi-config.yaml: This file provides project configuration data to SUSHI. It is described further in the Configuration documentation. input/fsh/*.fsh: FSH files contain the FHIR Shorthand definitions for all the resources and examples in your IG. ig.ini: Configuration file required for the FHIR IG Publication process. NOTE: As of the SUSHI 1.0 release, this file MUST use a template based on fhir.base.template#current. Specific template versions (i.e., other than #current) are expected to work in the future. For now, any of the following should work:  template = fhir.base.template#current template = hl7.base.template#current template = hl7.fhir.template#current template = hl7.davinci.template#current template = hl7.cda.template#current   input/ignoreWarnings.txt: This file is used to suppress specific QA warnings and information messages during the FHIR IG publication process. input/images/*: Put anything that is not a page in the IG, such as images, spreadsheets or zip files, in the input/images subdirectory. These files can be referenced by user-provided pages or menus. input/includes/menu.xml: If present, this file will be used for the IG’s main menu layout. Note that the presence of this file will block usage of the menu property in sushi-config.yaml. input/pagecontent/*: Put either markup (.xml) or markdown (.md) files with the narrative content of your IG in the input/pagecontent/ subdirectory. These files are the sources for the html pages that accompany the automatically-generated pages of your IG. The header and footer of these pages are automatically generated, so your content should not include these elements. Any number of pages can be added. In addition to stand-alone pages, you can provide additional text for generated artifact pages. The naming of these files is significant:  index.xml|md: This file provides the content for the IG’s main page. N_pagename.xml|md: If present, these files will be generated as individual pages in the IG. The leading integer (N) determines the order of the pages in the table of contents. Adding a leading integer is optional, and in the absence of a leading integer, SUSHI will sort the pages alphabetically. The order of the pages can also be explitly specified with the pages property in sushi-config.yaml. {artifact-file-name}-intro.xml|md: If present, the contents of the file will be placed on the relevant page before the artifact’s definition. {artifact-file-name}-notes.xml|md: If present, the contents of the file will be placed on the relevant page after the artifact’s definition.   input/{supported-resource-input-directory}/* (not shown above): JSON or XML files in supported resource directories (e.g., profiles, extensions, examples, etc.) can be referenced by FHIR artifacts defined in FSH, and will be added to the generated ImplementationGuide.json file. package-list.json: This optional file, described here, should contain the version history of your IG. sushi-ignoreWarnings.txt: This optional file described above can be used to suppress warnings logged by SUSHI.  Tip Examples of package.json, ig.ini, package-list.json, ignoreWarnings.txt and menu.xml files can be found in the sample IG project provided for this purpose. In addition, more general guidance can be found in Guidance for HL7 IG Creation.  Initializing a SUSHI Project Setting up this project structure manually can be complex, so to simplify that process, SUSHI provides an --init option. Running sushi --init will cause SUSHI to create a new SUSHI project with a default configuration and project structure. This provides a simple way to get started with FHIR Shorthand and SUSHI.\nWhen sushi --init is run, SUSHI will request high-level project information from the user:\nName (Default: ExampleIG): NewIG Id (Default: fhir.example): my.id Canonical (Default: http://example.org): http://myid.org Status (Default: draft): active Version (Default: 0.1.0): 2.0.0 Initialize SUSHI project in C:\\Users\\shorty\\dev\\NewIG? [y/n]: y These values are used to generate a simple sushi-config.yaml file and a corresponding IG-Publisher-compatible project structure:\nNewIG ├── .gitignore ├── _genonce.bat ├── _genonce.sh ├── _updatePublisher.bat ├── _updatePublisher.sh ├── ig.ini ├── input | ├── ignoreWarnings.txt | ├── fsh | | └── patient.fsh | └── pagecontent | └── index.md └── sushi-config.yaml In addition to the contents of the input/fsh folder, --init adds several .bat and .sh scripts which allow you to run the IG Publisher, a default .gitignore file for a FSH project, and two files (ig.ini and ignoreWarnings.txt) required by the template-based IG Publisher. From this point on, the author can modify the configuration and definitions as necessary.\n","excerpt":"Simple FSH Projects The simplest FSH project (sometimes referred to as …","ref":"/docs/sushi/project/","title":"Project Structure"},{"body":"Running GoFSH GoFSH is executed from the command line. The general form of the GoFSH execution command is as follows:\n gofsh {input-directory} {options} where options include the following (in any order):\n-o, --out \u003cout\u003e the path to the output folder -l, --log-level \u003clevel\u003e specify the level of log messages: error, warn, info (default), debug -d, --dependency \u003cdependency...\u003e specify dependencies to be loaded using format dependencyId@version (FHIR R4 included by default) -s, --style \u003cstyle\u003e specify how the output is organized into files: file-per-definition (default), group-by-fsh-type, group-by-profile, single-file -f, --fshing-trip run SUSHI on the output of GoFSH and generate a comparison of the round trip results -i, --installed-sushi use the locally installed version of SUSHI when generating comparisons with the \"-f\" option -t, --file-type \u003ctype\u003e specify which file types GoFSH should accept as input: json-only (default), xml-only, json-and-xml --indent output FSH with indented rules using context paths --meta-profile \u003cmode\u003e specify how meta.profile on Instances should be applied to the InstanceOf keyword: only-one (default), first, none -v, --version print goFSH version -h, --help display help for command While GoFSH is running, it will print status messages as it processes your project files. The following sections give further detail on using certain options.\nstyle The style option has four values:\n group-by-fsh-type: Definitions are written to files based on what type of FSH definition they are (Alias, Profile, Extension, etc.). This is the default choice. group-by-profile: Profiles are each written to an individual file. Instances and Invariants that pertain only to a certain Profile are then included in the same file as that Profile. The remaining definitions are grouped as in the group-by-fsh-type option. single-file: All definitions are written to one file. file-per-definition: Each standalone FSH definition is written to an individual file. Only Aliases are combined into one aliases.fsh file.  fshing-trip If this flag is added, after GoFSH runs, SUSHI will run on the output of GoFSH. The output of SUSHI will then be compared to the original input to GoFSH (FHIR is compared to FHIR), and a visualization of differences between the original input and the SUSHI output will be created in \u003coutput-folder\u003e/fshing-trip-comparison.html. If the --installed-sushi flag is set, then this process will use whichever version of SUSHI you have globally installed. Otherwise GoFSH will use its own built-in version of SUSHI (which may not be the latest version available).\nindent When the --indent option is specified, the output FSH will take advantage of indented rules when applicable. This will also cause CodeSystem definitions to utilize indentation in hierarchical codes, Concept designations, and Concept properties when applicable.\nmeta-profile The --meta-profile option can be used to control how meta.profile on instances should be applied to the InstanceOf keyword. The option has the following three values:\n only-one (default): If there is exactly one entry in the meta.profile array of a definition, this value will be used to set InstanceOf. If there is not exactly one entry in the meta.profile array, the resourceType of the definition will be used for InstanceOf, and any contents of the meta.profile array will be specified with ^ rules. first: If there is at least one entry in the meta.profile array, it will be used to set InstanceOf. Additional entries will be specified with ^ rules. none: The meta.profile array will not be used to determine InstanceOf.  GoFSH Inputs GoFSH takes FHIR StructureDefinitions and other FHIR conformance definitions (e.g., ValueSets, CodeSystems) as input. GoFSH requires that these files be JSON. Every JSON file contained in the input directory, or its subdirectories, will be processed by GoFSH into FSH.\nGoFSH does not require any configuration, but if the input FHIR artifacts depend on FHIR artifacts not contained in FHIR R4, these dependencies should be specified with the -d flag. For example, the mcode-cancer-patient profile in the mCODE Implementation Guide is derived from the us-core-patient profile in the US Core Implementation Guide. If you wanted to use GoFSH to convert the mcode-cancer-patient profile to FSH, you should specify US Core as a dependency:\n gofsh ./mcode-definitions -d hl7.fhir.us.core@3.1.0  Info GoFSH can still generate FSH when dependencies are omitted, but the resulting FSH will be incomplete.  GoFSH Outputs GoFSH populates an output directory, called gofsh by default. This directory will contain an input/fsh directory. The input/fsh directory will contain several .fsh files organized according to the group-by-fsh-type style described above. Additionally, the input/fsh directory will contain an index.txt file which describes which file contains each definition. The gofsh directory will also contain a sushi-config.yaml file. If the input to GoFSH includes an ImplementationGuide resource, it is used to generate the configuration. Otherwise the configuration is generated by inferring values from the input, or by using sensible defaults if no values can be inferred. These definitions and configuration are ready to use with SUSHI, all you have to do is run SUSHI.\n","excerpt":"Running GoFSH GoFSH is executed from the command line. The general …","ref":"/docs/gofsh/running/","title":"Running GoFSH"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  This section contains documentation for SUSHI (SUSHI Unshortens ShortHand Inputs), a reference implementation FSH compiler.\n","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/sushi/","title":"SUSHI"},{"body":"This section contains documentation for SUSHI (SUSHI Unshortens ShortHand Inputs), a reference implementation FSH compiler.\n","excerpt":"This section contains documentation for SUSHI (SUSHI Unshortens …","ref":"/docs/sushi/","title":"SUSHI"},{"body":"FHIR Shorthand (FSH) is a specially-designed language for defining the content of FHIR Implementation Guides (IGs). It is simple and compact, with tools to produce Fast Healthcare Interoperability Resources (FHIR) profiles, extensions and IGs. FSH is compiled from text files to FHIR artifacts using SUSHI. To get started using FSH, you need to install and run SUSHI using the steps below.\nStep 1: Review Introduction If you haven’t done so already, please read or review the Introduction documentation to gain an understanding of the conventions used in this tutorial and the resources available to you.\nStep 2: Install Node.js and Sushi If you have not already installed SUSHI, follow the SUSHI Installation instructions.\nStep 3: Download Sample FSH Tank To start with some working examples of FSH files and a skeleton FSH tank,  download the FSH Tutorial Starter and unzip it into a directory of your choice.\nAfter the file is unzipped, you should see two subdirectories:\n FishExample FishExampleComplete  Change the working directory to FishExample. There is a sushi-config.yaml file, and two FSH files within the /input/fsh subdirectory:\n FishPatient.fsh Veterinarian.fsh  In addition, there are several files for building the IG.\nStep 4: Run SUSHI Now that you have SUSHI installed and a minimal FSH tank, open up a command window, and navigate to the FishExample directory. Run SUSHI on those FSH files by executing:\n sushi .  Note The dot (.) represents “this directory,” the location of the FSH files. You can also specify the location explicitly by replacing the dot with a directory path.  Running SUSHI will create a FishExample/fsh-generated directory, and populate it with the files needed to create the IG using the HL7 FHIR IG Publisher tool.\nWhile running SUSHI, there will be a series of informational messages. When SUSHI completes, you should see a summary output similar this:\n╔════════════════════════ SUSHI RESULTS ══════════════════════════╗ ║ ╭──────────┬────────────┬───────────┬─────────────┬───────────╮ ║ ║ │ Profiles │ Extensions │ ValueSets │ CodeSystems │ Instances │ ║ ║ ├──────────┼────────────┼───────────┼─────────────┼───────────┤ ║ ║ │ 2 │ 0 │ 0 │ 0 │ 0 │ ║ ║ ╰──────────┴────────────┴───────────┴─────────────┴───────────╯ ║ ║ ║ ╠═════════════════════════════════════════════════════════════════╣ ║ You are dolphinitely doing great! 0 Errors 0 Warnings ║ ╚═════════════════════════════════════════════════════════════════╝ The files generated by SUSHI are located in the FishExample/fsh-generated directory. Check that the FishExample/fsh-generated/resources subdirectory contains two generated StructureDefinitions and a generated ImplementationGuide.\nStep 5: Generate the Sample IG At the command prompt, enter:\n  _updatePublisher   ./_updatePublisher.sh This will download the latest version of the HL7 FHIR IG Publisher tool into ./input-cache. This step can be skipped if you already have run the command recently, and have the latest version of the IG Publisher tool.\nTip If you are blocked by a firewall, or if for any reason _updatePublisher fails to execute, download the current IG Publisher jar file here. When the file has downloaded, move it into the directory /FishExample/input-cache (creating the directory if necessary).  Warning Before proceeding to the next command: If you have never run the IG Publisher, you may need to install Jekyll first. See Installing the IG Publisher for details.  Now run:\n  _genonce   ./_genonce.sh This will run the HL7 FHIR IG generator, which may take several minutes to complete.\nAfter the publisher is finished, open the file /FishExample/output/index.html to see the resulting IG.\nIf you click on the Artifacts Summary item in the menu, you will see that the IG contains two profiles, FishPatient and Veterinarian. If you look at each of them, you will notice that they have minimal differentials. The only way in which they differ from their base resource is that they require at least one name.\nStep 6: Setting Cardinalities in a Profile It is not widely known, but FHIR is designed to be used for veterinary medicine as well as human. For a non-human patient, we need to record the species. The Patients in this Tutorial are going to be various species of fish 🐟.\nSince fish don’t get legally married (although some species do pair bond) and they don’t communicate in a human language, the first thing we’ll do in the FishPatient profile is eliminate these elements. To do this, open the file FishPatient.fsh in your favorite plain-text editor, and add the following rules after the last non-blank line in the file:\n* maritalStatus 0..0 * communication 0..0 Note that rules start with *. FSH expresses cardinality as, {min}..{max}, the same as FHIR.\nStep 7: Create a Species Extension for FishPatient To specify the species of our aquatic patients, we’ll need an extension.\nWe have a choice of whether to make the extension inline or standalone. Inline extensions do not result in a separate StructureDefinition, and cannot be reused in other profiles. Standalone extensions are the opposite: they have independent StructureDefinitions, and can be reused. For this example, let’s make a standalone extension.\nExtensions are created using the contains keyword. To add a standalone species extension, add the following rule after the cardinality rules:\n* extension contains FishSpecies named species 0..1 This rule states that the extension array of the Patient resource will incorporate the FishSpecies extension with the local name species.\nTo define the FishSpecies extension, add the following lines to the end of the FishPatient.fsh file:\nExtension: FishSpecies Id: fish-species Title: \"Fish Species\" Description: \"The species of the fish.\"  Tip FSH ignores extra whitespace, so authors can choose to use whitespace for improved visual alignment, as in the extension definition above.  Run SUSHI again (sushi .). The count of Extensions should now be 1.\nStep 8: Define a Value Set for Fish Species The FishSpecies extension doesn’t quite do its job yet, because we haven’t specified what type of values it might accept. To add this information, enter these lines following the description of FishSpecies:\n* value[x] only CodeableConcept * valueCodeableConcept from FishSpeciesValueSet (extensible) The first rule restricts the value[x] (a built-in element of every FHIR extension) to a CodeableConcept using the only keyword. The second binds it to a value set (yet to be defined) using the from keyword. The binding strength will be extensible, meaning the codes in the FishSpeciesValueSet must be used except when the value set is missing a specific fish species.\nTo define FishSpeciesValueSet, add the following lines to the same file:\nValueSet: FishSpeciesValueSet Title: \"Fish Species Value Set\" Id: fish-species-value-set Description: \"Codes describing various species of fish, taken from SNOMED-CT.\" * codes from system http://snomed.info/sct where concept is-a SCT#90580008 \"Fish (organism)\"  Info The rule in the value set definition above selects all codes from SNOMED-CT that are children of the concept “Fish (organism)”.  Run SUSHI again. The count of ValueSets should now be 1. Try generating the IG by running _genonce again. Open the file /FishExample/output/index.html to see the resulting IG.\n Do you see where the FishPatient profile is in the IG? Does the differential reflect your changes? How does FHIR render the value set you defined?  Step 9: Define an Alias An Alias is a way to define a shorthand for a URL or OID. For example, in the value set definition above, we could have defined an Alias to make referencing the http://snomed.info/sct URL easier, as shown below. Aliases are conventionally defined at the top of the file.\nAdd this line at the top of the FishPatient.fsh file:\nAlias: SCT = http://snomed.info/sct and then replace the last line in the FishSpeciesValueSet with:\n* codes from system SCT where concept is-a #90580008 \"Fish (organism)\"  Tip Using aliases has no effect on the IG; it simply makes the FSH code a bit neater.  Step 10: Create an Instance of FishPatient Every IG should provide examples of its profiles. Let’s do that by introducing an example FishPatient named Shorty. Create this example instance using the Instance keyword, with InstanceOf set to FishPatient and Usage set to Example.\nInclude the following information about Shorty in the instance:\n His given (first) name is “Shorty” and his family (last) name is “Koi-Fish”. Shorty is a Koi fish (Cyprinus rubrofuscus), represented as SNOMED-CT code 47978005 “Carpiodes cyprinus (organism)”.  If you need help with this, you can reference the Defining Instances section of the specification. If you still need help, you can peek at the FSH files in the FishExampleComplete directory.\nRun SUSHI again, and re-generate the IG.\n Did it compile without errors? What does the IG look like now?  Step 11: Extend the Veterinarian Profile Now, add constraints and/or extensions to the Veterinarian profile:\n  Add qualifications consistent with a Veterinary practice. Qualifications are taken from code system http://nucc.org/provider-taxonomy, and the code is 174M00000X, for “Veterinarian”.\n  In addition, slice the identifier array, making a license number required. The code system is http://terminology.hl7.org/CodeSystem/v2-0203 and the code is LN, for “License number”.\n  If you need help with this, you can refer to the assignment rules and slicing rules sections of the specification. If you still need help, you can peek at the FSH files in the FishExampleComplete directory.\nRun SUSHI again, and re-generate the IG.\n Did it compile without errors? What does the IG look like now?  Congratulations! You’ve completed the FSH tutorial. It might be time to feast on some sushi!\n","excerpt":"FHIR Shorthand (FSH) is a specially-designed language for defining the …","ref":"/docs/tutorials/basic/","title":"SUSHI Tutorial"},{"body":"This section contains documentation for GoFSH, which turns FHIR artifacts into FSH definitions. Using GoFSH, you can turn an existing FHIR Implementation Guide into a FSH project automatically.\nIf you are starting a project from scratch, see Initializing a SUSHI Project.\n","excerpt":"This section contains documentation for GoFSH, which turns FHIR …","ref":"/docs/gofsh/","title":"GoFSH"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  The HL7 FHIR IG Publisher relies on several configuration files, including ig.ini, package-list.json, menu.xml, and an instance of the ImplementationGuide resource. Splitting information among multiple files and managing different formats makes IG configuration difficult to manage.\nSUSHI offers the same functionality in a single config.yaml file, allowing all configuration to be in a consistent format with no duplication of information. This file is written using YAML. Authors unfamiliar with YAML should note that:\n White space (new lines and indentation) is significant Information is presented in key: value pairs Strings do not have to be quoted unless they contain reserved characters, such as colon (:) Arrays/sequences are created using -  Minimum Configuration At a minimum, the config.yaml file must provide a few high-level metadata values for the FSH project, if the author wishes for SUSHI to do additional Implementation Guide (IG) processing:\nid:fhir.us.examplecanonical:http://hl7.org/fhir/us/examplename:ExampleIGstatus:draftversion:0.1.0fhirVersion:4.0.1copyrightYear:2020+releaseLabel:ci-buildtemplate:hl7.fhir.template#0.0.5 Download Minimum Configuration Example\n For an official HL7 project, the id and canonical will typically be assigned by the FHIR Product Director. Valid values for status include:  draft: The IG is still under development and is not yet considered to be ready for normal use. active: The IG is ready for normal use. retired: The IG has been withdrawn or superseded and should no longer be used. unknown: It is not know which of the status values currently applies for the IG. This should be rare.   Since SUSHI currently supports only FHIR R4, the fhirVersion should always be 4.0.1. Valid values for the releaseLabel include:  ci-build: the continuous integration build release (not stable) draft: draft version qa-preview: frozen snapshot for non-ballot feedback ballot: frozen snapshot for ballot trial-use: official release with ‘trial use’ status release: official release for use update: official release with ‘trial use’ status - posted as an un-balloted STU update normative+trial-use: official release with mixture of trial use and normative content   The template value consists of a template id and version separated by #. This value will be reflected in the generated ig.ini file for your project. For the most up-to-date list of templates, see the Guidance for FHIR IG Creation.  Tip SUSHI can generate a simple configuration file for you with the --init option  FSH-Only If an author wants SUSHI only to build the FHIR definition files, and not to do any additional IG processing, and if the project contains an ImplementationGuide resource, then the author does not need to provide a config.yaml at all. If there is no config.yaml, SUSHI will automatically attempt to extract the following information from an ImplementationGuide resource:\n canonical fhirVersion version dependencies  SUSHI will then run in FSH-Only mode to produce FHIR definition files only.\nWhen attempting to extract information from an ImplementationGuide resource, SUSHI assumes the project structure required by the template-based IG Publisher. The following approach is used to find the ImplementationGuide resource:\n Look for \u003croot\u003e/ig.ini, where \u003croot\u003e is the folder containing the fsh subdirectory. If the ig.ini file exists, it will have an ig property which gives the path to the ImplementationGuide resource, so SUSHI will use this path to find the resource. If there is no ig.ini in the root folder, SUSHI will search the \u003croot\u003e/input folder for an ImplementationGuide resource, and if exactly one resource is found, SUSHI will extract the above properties from it.  If an author does not have an ImplementationGuide resource, but still wants SUSHI to build FHIR definition files only, the author should add a FSHOnly flag to the config.yaml and set its value to true:\nFSHOnly:trueHowever, the author will also at least need to provide a canonical and fhirVersion in the configuration for FSH-Only processing to succeed.\nRecommended Configuration In addition to the minimum configuration requirements shown above, most IG authors will also want to provide a title, description, license, publisher, and dependencies:\nid:fhir.us.examplecanonical:http://hl7.org/fhir/us/examplename:ExampleIGtitle:\"HL7 FHIR Implementation Guide: Example IG Release 1 - US Realm | STU1\"description:AnexampleIGthatexercisesmanyofthefieldsinaSUSHIconfigurationstatus:draftlicense:CC0-1.0version:0.1.0fhirVersion:4.0.1copyrightYear:2020+releaseLabel:ci-buildpublisher:name:HL7International- USRealmSteeringCommitteeurl:http://www.hl7.org/Special/committees/usrealm/index.cfmemail:usrsc@lists.HL7.orgdependencies:hl7.fhir.us.core:3.1.0template:hl7.fhir.template#0.0.5 Download Recommended Configuration Example\n The license value should come from the SPDX Licence Value Set, although most FHIR IGs use the CC0-1.0 (Creative Commons Zero v1.0 Universal) license. The dependencies value is a YAML object for which the keys are each dependency’s package id and the values are the dependency versions. In addition to standard version identifiers, the following two special versions are supported:  dev: indicates that the dependency should be loaded from the local FHIR cache current: indicates that the dependency should be loaded from the last successful auto-build.   The dependencies property also supports an advanced syntax that allows you to directly specify the dependency id and/or URI if necessary. For example: dependencies:hl7.fhir.us.core:id:uscoreuri:http://hl7.org/fhir/us/core/ImplementationGuide/hl7.fhir.us.coreversion:3.1.0  Full Configuration The table below lists all configuration properties that can be used in SUSHI’s config.yaml file. Most SUSHI configuration properties come directly from the Implementation Guide resource and will be translated into the generated ImplementationGuide resource for your project. Differences between the config.yaml properties and ImplementationGuide properties are noted below.\n   Property Corresponding IG element Usage     id id As specified in the IG resource   meta meta As specified in the IG resource   implicitRules implicitRules As specified in the IG resource   language language As specified in the IG resource   text text As specified in the IG resource   contained contained As specified in the IG resource   extension extension As specified in the IG resource   modifierExtension modifierExtension As specified in the IG resource   url url As specified in the IG resource. If not specified, defaults to {canonical}/ImplementationGuide/{id}.   version version As specified in the IG resource   name name As specified in the IG resource   title title As specified in the IG resource   status status As specified in the IG resource   experimental experimental As specified in the IG resource   date date As specified in the IG resource   publisher publisher, with cardinality changed to 0..* Publisher can be a single item or a list, each with a name and optional url and/or email. The first publisher’s name will be used as IG.publisher. The contact details and/or additional publishers will be translated into IG.contact values   contact contact As specified in the IG resource   description description As specified in the IG resource   useContext useContext As specified in the IG resource   jurisdiction jurisdiction As specified in the IG resource   copyright copyright As specified in the IG resource   packageId packageI As specified in the IG resource. If not specified, defaults to id.   license license As specified in the IG resource   fhirVersion fhirVersion As specified in the IG resource   dependencies dependsOn A key: value pair, where key is the package id and value is the version (or dev/current). For advanced use cases, the value can be an object with keys for id, uri and version.   global global Key is the type and value is the profile   groups definition.grouping A key: value pair, where key is the name of the group and value is the description of the group   resources definition.resource SUSHI can auto-generate a list of resources based on FSH definitions and provided JSON or XML resources, but this property can be used to add additional entries or override generated entries. SUSHI uses the {resource type}/{resource name} format as the YAML key (corresponding to IG.definition.resource.reference). Authors can specify the value “omit” to omit a FSH-generated resource from the resource list. groupingId can be used, but top-level groups syntax may be a better option.   pages definition.page SUSHI can auto-generate pages, but authors can manage pages through this property. If this property is used, SUSHI will not generate any page entries. The YAML key is the file name containing the page. The title key-value pair provides the title for the page. If a title is not provided, then the title will be generated from the file name. If a generation value (corresponding to definition.page.generation) is not provided, it will be inferred from the file name extension. In the IG resource, pages can contain sub-pages; so in the config file, any sub-properties that are valid filenames with supported extensions (e.g., .md/.xml) will be treated as sub-pages.   parameters definition.parameter The key is the code. If a parameter allows repeating values, the value in the YAML may be a sequence/array.   templates definition.template As specified in the IG resource   copyrightYear or copyrightyear N/A Used to add a copyrightyear parameter to IG.definition.parameter   releaseLabel or releaselabel N/A Used to add a releaseLabel parameter to IG.definition.parameter   canonical N/A The canonical URL to be used throughout the IG   template N/A Template used in ig.ini file. Authors can provide their own ig.ini file by removing this property and placing an igi.ini file in the ig-data directory.   menu N/A Used to generate the input/index.md file. The key is the menu item name and the value is the URL. Menus can contain sub-menus, but the IG Publisher currently only supports sub-menus one level deep. Authors can provide their own menu.xml by removing this property and placing a menu.xml file in ig-data/input/includes   history N/A Used to create a package-list.json. SUSHI will use the existing top-level properties in its config to populate the top-level package-list.json properties: package-id, canonical, title, and introduction. Authors who wish to provide different values can supply them as properties under history. All other properties under history are assumed to be versions. Additionally, the current version is special. If the author provides only a single string value, it is assumed to be the URL path to the current build. The following default values will then be used: desc: Continuous Integration Build (latest in version control), status: ci-build, and current: true. Authors can provide their own package-list.json by removing this property and placing a package-list.json file in ig-data.   indexPageContent N/A This property is provided for backwards compatibility reasons, and its use is discouraged. It was used to specify the content of index.md, however, authors should provide their own index file by not using this property and placing an index.md or index.html file in input/pages or input/pagecontent.   FSHOnly N/A When this flag is set to true, no IG specific content will be generated, SUSHI will only convert FSH definitions to JSON files. When false or unset, IG content is generated.    Exhaustive Example The following provides an exhaustive example config.yaml covering many of the properties discussed above.\n# This IG YML file is inspired by the ImplementationGuide resource# and also draws from package.json, package-list.json, and ig.ini.# That said, it is structured for ease-of-use, so it is not strictly# conformant to any of those existing configuration formats.# SUSHI will use id as both id and packageId in the IG unless a# specific packageId is also provided in this file.id:fhir.us.examplecanonical:http://hl7.org/fhir/us/exampleurl:http://hl7.org/fhir/us/example/ImplementationGuide/fhir.us.examplename:ExampleIGtitle:\"HL7 FHIR Implementation Guide: Example IG Release 1 - US Realm | STU1\"description:ExampleIGexercisesmanyofthefieldsinaSUSHIconfiguration.status:activelicense:CC0-1.0date:2020-02-26version:1.0.0# Although fhirVersions is 0..* in the ImplementationGuide resource# it can be a single item OR and array here (but so far SUSHI only# supports 4.0.1 anyway).fhirVersion:4.0.1# The template property will be used to generate an ig.ini file.# To provide a custom ig.ini file, do not include this property and# include an `ig.ini` file in ig-data.template:hl7.fhir.template#0.0.5# The following two lines correspond to items that used to be in# ig.ini but were moved to IG.definition.parameter. For# consistency within this file, the names are represented using# camelcase, but if authors use the formal parameter names, SUSHI# will recognize them as well. In either case, they'll be copied# to the IG JSON using the formal names.copyrightYear:2019+releaseLabel:STU1# The publisher can be a single item or a list, each with a name and# optional url and/or email. The first publisher's name will be used# as IG.publisher. The contact details and/or additional publishers# will be translated into IG.contact values.publisher:name:HL7FHIRManagementGroupurl:http://www.hl7.org/Special/committees/fhirmgemail:fmg@lists.HL7.org# Those who need more control or want to add additional details to the contact values can use# contact directly and follow the format outlined in the ImplementationGuide resource and# ContactDetail.contact:- name:BobSmithtelecom:- system:emailvalue:bobsmith@example.orguse:work# The jurisdiction can be a single item or a list. The FHIR Shorthand# code syntax can be used here.jurisdiction:urn:iso:std:iso:3166#US \"United States of America\"# The dependencies property corresponds to IG.dependsOn. The key is the# package id and the value is the version (or dev/current). For advanced# use cases, the value can be an object with keys for `uri` and `version`.dependencies:hl7.fhir.us.core:3.1.0hl7.fhir.us.mcode:id:mcodeuri:http://hl7.org/fhir/us/mcode/ImplementationGuide/hl7.fhir.us.mcodeversion:1.0.0# The global property corresponds to the IG.global property, but it# uses the type as the YAML key and the profile as its value. Since# FHIR does not explicitly disallow more than one profile per type,# neither do we; the value can be a single profile URL or an array# of profile URLs.global:Patient:http://example.org/fhir/StructureDefinition/my-patient-profileEncounter:http://example.org/fhir/StructureDefinition/my-encounter-profile# The resources property corresponds to IG.definition.resource.# SUSHI can auto-generate all of the resource entries based on# the FSH definitions and/or information in any user-provided# JSON or XML resource files. If the generated entries are not# sufficient or complete, however, the author can add entries# here. If the reference matches a generated entry, it will# replace the generated entry. If it doesn't match any generated# entries, it will be added to the generated entries. The format# follows IG.definition.resource with the following differences:# * use IG.definition.resource.reference.reference as the YAML key# * specify \"omit\" to omit a FSH-generated resource from the# resource list.# * groupingId can be used, but top-level groups syntax may be a# better option (see below).# The following are simple examples to demonstrate what this might# look like:resources:Patient/my-example-patient:name:MyExamplePatientdescription:AnexamplePatientexampleBoolean:truePatient/bad-example:omit# Groups can control certain aspects of the IG generation. The IG# documentation recommends that authors use the default groups that# are provided by the templating framework, but if authors want to# use their own instead, they can use the mechanism below. This will# create IG.definition.grouping entries and associate the individual# resource entries with the corresponding groupIds.groups:GroupA:description:TheAlphaGroupresources:- StructureDefinition/animal-patient- StructureDefinition/arm-procedureGroupB:description:TheBetaGroupresources:- StructureDefinition/bark-control- StructureDefinition/bee-sting# The pages property corresponds to IG.definition.page. SUSHI can# auto-generate the page list, but if the author includes pages in# this file, it is assumed that the author will fully manage the# pages section and SUSHI will not generate any page entries.# The page file name is used as the key. If title is not provided,# then the title will be generated from the file name. If a# generation value is not provided, it will be inferred from the# file name extension. Any subproperties that are valid filenames# with supported extensions (e.g., .md/.xml) will be treated as# sub-pages.pages:index.md:title:ExampleHomeimplementation.xml:examples.xml:title:ExamplesOverviewsimpleExamples.xml:complexExamples.xml:# The ImplementationGuide resource defines several other properties# not represented above. These properties can be used as-is and# should follow the format defined in ImplementationGuide:# * meta# * implicitRules# * language# * text# * contained# * extension# * modifierExtension# * experimental# * useContext# * copyright# * packageId# The menu property will be used to generate the input/menu.xml file.# The menu is represented as a simple structure where the YAML key# is the menu item name and the value is the URL. The IG publisher# currently only supports one level deep on sub-menus.# To provide a custom menu.xml file, do not include this property and# include a `menu.xml` file in input/includes.menu:Home:index.htmlArtifacts:Profiles:artifacts.html#2Extensions:artifacts.html#3Value Sets:artifacts.html#4Downloads:downloads.htmlHistory:http://hl7.org/fhir/us/example/history.html# The parameters property represents IG.definition.parameter. Rather# than a list of code/value pairs (as in the ImplementationGuide# resource), the code is the YAML key. If a parameter allows repeating# values, the value in the YAML should be a sequence/array. For a# partial list of allowed parameters see:# https://confluence.hl7.org/display/FHIR/Implementation+Guide+Parametersparameters:excludettl:truevalidation:[allow-any-extensions,no-broken-links]# The history property corresponds to package-list.json. SUSHI will# use the existing top-level properties in its config to populate the# top-level package-list.json properties: packageId, canonical, title,# and introduction. Authors that wish to provide different values can# supply them as properties under history. All other properties under# history are assumed to be versions. To provide a custom package-list.json# file, remove this property and include a package-list.json file in ig-data.history:# The current version is special. If the author provides only a# single value, it is assumed to be the URL path to the current# build. The following default values will then be used:# desc: Continuous Integration Build (latest in version control)# status: ci-build# current: truecurrent:http://build.fhir.org/ig/HL7/example-ig/# All other versions need each of their values fully specified.# See: https://confluence.hl7.org/pages/viewpage.action?pageId=66928420#FHIRIGPackageListdoco-PublicationObject1.0.0:fhirversion:4.0.1date:2020-03-06desc:STU1Releasepath:https://hl7.org/fhir/us/example/STU1/status:trial-usesequence:STU1current:true0.9.1:fhirversion:4.0.0date:2019-06-10desc:InitialSTUballot(Sep2019Ballot)path:https://hl7.org/fhir/us/example/2019Sep/status:ballotsequence:STU1# The indexPageContent property is used to generate a basic index.md file. To provide a# custom index file, do not include this property and include an index.md or index.xml file# in input/pages/ or input/pagecontent folders.indexPageContent:'Example Index Page Content'# The FSHOnly flag indicates if only FSH resources should be exported.# If set to true, no IG related content will be generated.# The default value for this property is false.FSHOnly:false Download Exhaustive Configuration Example\n","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/sushi/configuration/","title":"Configuration"},{"body":"SUSHI is configured by a single sushi-config.yaml file. This file is written using YAML. Authors unfamiliar with YAML should note that:\n White space (new lines and indentation) is significant Information is presented in key: value pairs Strings do not have to be quoted unless they contain reserved characters, such as colon (:) Arrays/sequences are created using -  Minimum Configuration At a minimum, the sushi-config.yaml file must provide a few high-level metadata values for the FSH project, if the author wishes for SUSHI to do additional Implementation Guide (IG) processing:\nid:fhir.us.examplecanonical:http://hl7.org/fhir/us/examplename:ExampleIGstatus:draftversion:0.1.0fhirVersion:4.0.1copyrightYear:2020+releaseLabel:ci-build Download Minimum Configuration Example\n For an official HL7 project, the id and canonical will typically be assigned by the FHIR Product Director. Valid values for status include:  draft: The IG is still under development and is not yet considered to be ready for normal use. active: The IG is ready for normal use. retired: The IG has been withdrawn or superseded and should no longer be used. unknown: It is not know which of the status values currently applies for the IG. This should be rare.   Since SUSHI currently supports only FHIR R4 and R5, the fhirVersion should always be 4.0.0 or above. Valid values for the releaseLabel include:  ci-build: the continuous integration build release (not stable) draft: draft version qa-preview: frozen snapshot for non-ballot feedback ballot: frozen snapshot for ballot trial-use: official release with ‘trial use’ status release: official release for use update: official release with ‘trial use’ status - posted as an un-balloted STU update normative+trial-use: official release with mixture of trial use and normative content    Tip SUSHI can generate a simple configuration file for you with the --init option  FSH-Only If an author wants SUSHI only to build the FHIR definition files, and not to do any additional IG processing, and if the project contains an ImplementationGuide resource, then the author does not need to provide a sushi-config.yaml at all. If there is no sushi-config.yaml, SUSHI will automatically attempt to extract the following information from an ImplementationGuide resource:\n canonical fhirVersion version dependencies  SUSHI will then run in FSH-Only mode to produce FHIR definition files only.\nWhen attempting to extract information from an ImplementationGuide resource, SUSHI assumes the project structure required by the template-based IG Publisher. The following approach is used to find the ImplementationGuide resource:\n Look for \u003croot\u003e/ig.ini, where \u003croot\u003e is the folder containing the input folder. If the ig.ini file exists, it will have an ig property which gives the path to the ImplementationGuide resource, so SUSHI will use this path to find the resource. If there is no ig.ini in the root folder, SUSHI will search the \u003croot\u003e/input folder for an ImplementationGuide resource, and if exactly one resource is found, SUSHI will extract the above properties from it.  If an author does not have an ImplementationGuide resource, but still wants SUSHI to build FHIR definition files only, the author should add a FSHOnly flag to the sushi-config.yaml and set its value to true:\nFSHOnly:trueHowever, the author will also at least need to provide a canonical and fhirVersion in the configuration for FSH-Only processing to succeed.\nRecommended Configuration In addition to the minimum configuration requirements shown above, most IG authors will also want to provide a title, description, license, publisher, and dependencies:\nid:fhir.us.examplecanonical:http://hl7.org/fhir/us/examplename:ExampleIGtitle:\"HL7 FHIR Implementation Guide: Example IG Release 1 - US Realm | STU1\"description:AnexampleIGthatexercisesmanyofthefieldsinaSUSHIconfigurationstatus:draftlicense:CC0-1.0version:0.1.0fhirVersion:4.0.1copyrightYear:2020+releaseLabel:ci-buildpublisher:name:HL7International- USRealmSteeringCommitteeurl:http://www.hl7.org/Special/committees/usrealm/index.cfmemail:usrsc@lists.HL7.orgdependencies:hl7.fhir.us.core:3.1.0 Download Recommended Configuration Example\nNote The license value should come from the SPDX Licence Value Set, although most FHIR IGs use the CC0-1.0 (Creative Commons Zero v1.0 Universal) license.  Dependencies The dependencies value is a YAML object for which the keys are each dependency’s package id and the values are the dependency versions. In addition to standard version identifiers, the following two special versions are supported:\n dev: indicates that the dependency should be loaded from the local FHIR cache current: indicates that the dependency should be loaded from the last successful auto-build.  The dependencies property also supports an advanced syntax that allows you to directly specify the dependency id and/or URI if necessary. For example:\ndependencies:hl7.fhir.us.core:id:uscoreuri:http://hl7.org/fhir/us/core/ImplementationGuide/hl7.fhir.us.coreversion:3.1.0SUSHI also supports extensions for converting between versions of FHIR. To get extensions that represent elements from other versions of FHIR, a package of the form hl7.fhir.extensions.\u003cextension-version\u003e:\u003cpackage-version\u003e is used. The \u003cextension-version\u003e should be one of r2, r3, or r4 to indicate which version of FHIR the element represented by the extension is defined in. The \u003cpackage-version\u003e represents which version of FHIR the extension will be used in. For an IG defined using FHIR R4, this would be 4.0.1. As an example, if an author wanted to represent the Patient.animal.species element as defined in R3, the dependencies should be specified as:\ndependencies:hl7.fhir.extensions.r3:4.0.1An author can then reference the extension using a URL following the format defined in the FHIR specification linked above. For example, the extension referring to the R3 Patient.animal.species element would be: http://hl7.org/fhir/3.0/StructureDefinition/extension-Patient.animal.species.\nFull Configuration The table below lists all configuration properties that can be used in SUSHI’s sushi-config.yaml file. Most SUSHI configuration properties come directly from the Implementation Guide resource and will be translated into the generated ImplementationGuide resource for your project. Differences between the sushi-config.yaml properties and ImplementationGuide properties are noted below.\n   Property Corresponding IG element Usage     id id As specified in the IG resource   meta meta As specified in the IG resource   implicitRules implicitRules As specified in the IG resource   language language As specified in the IG resource   text text As specified in the IG resource   contained contained As specified in the IG resource   extension extension As specified in the IG resource   modifierExtension modifierExtension As specified in the IG resource   url url As specified in the IG resource. If not specified, defaults to {canonical}/ImplementationGuide/{id}.   version version As specified in the IG resource   name name As specified in the IG resource   title title As specified in the IG resource   status status As specified in the IG resource   experimental experimental As specified in the IG resource   date date As specified in the IG resource   publisher publisher, with cardinality changed to 0..* Publisher can be a single item or a list, each with a name and optional url and/or email. The first publisher’s name will be used as IG.publisher. The contact details and/or additional publishers will be translated into IG.contact values   contact contact As specified in the IG resource   description description As specified in the IG resource   useContext useContext As specified in the IG resource   jurisdiction jurisdiction As specified in the IG resource   copyright copyright As specified in the IG resource   packageId packageI As specified in the IG resource. If not specified, defaults to id.   license license As specified in the IG resource   fhirVersion fhirVersion As specified in the IG resource   dependencies dependsOn A key: value pair, where key is the package id and value is the version (or dev/current). For advanced use cases, the value can be an object with keys for id, uri and version.   global global Key is the type and value is the profile   groups definition.grouping A key: value pair, where key is the group id and value is the description of the group. For advanced use cases, the value can be an object with keys for name, description, and resources.   resources definition.resource SUSHI can auto-generate a list of resources based on FSH definitions and provided JSON or XML resources, but this property can be used to add additional entries or override generated entries. SUSHI uses the {resource type}/{resource name} format as the YAML key (corresponding to IG.definition.resource.reference). Authors can specify the value “omit” to omit a FSH-generated resource from the resource list. groupingId can be used, but top-level groups syntax may be a better option.   pages definition.page SUSHI can auto-generate pages, but authors can manage pages through this property. If this property is used, SUSHI will not generate any page entries. The YAML key is the file name containing the page. The title key-value pair provides the title for the page. If a title is not provided, then the title will be generated from the file name. If a generation value (corresponding to definition.page.generation) is not provided, it will be inferred from the file name extension. In the IG resource, pages can contain sub-pages; so in the config file, any sub-properties that are valid filenames with supported extensions (e.g., .md/.xml) will be treated as sub-pages.   parameters definition.parameter The key is the code. If a parameter allows repeating values, the value in the YAML may be a sequence/array.   templates definition.template As specified in the IG resource   copyrightYear or copyrightyear N/A Used to add a copyrightyear parameter to IG.definition.parameter   releaseLabel or releaselabel N/A Used to add a releaseLabel parameter to IG.definition.parameter   canonical N/A The canonical URL to be used throughout the IG   menu N/A Used to generate the fsh-generated/includes/menu.xml file. The key is the menu item name and the value is the URL. Menus can contain sub-menus, but the IG Publisher currently only supports sub-menus one level deep. Authors can provide their own menu.xml by removing this property and placing a menu.xml file in /input/includes   FSHOnly N/A When this flag is set to true, no IG specific content will be generated, SUSHI will only convert FSH definitions to JSON files. When false or unset, IG content is generated.   applyExtensionMetadataToRoot N/A When set to true, the “short” and “definition” field on the root element of an Extension will be set to the “Title” and “Description” of that Extension. Default is true.    Exhaustive Example The following provides an exhaustive example sushi-config.yaml covering many of the properties discussed above.\n# This IG YML file is inspired by the ImplementationGuide resource# and also draws from package.json, package-list.json, and ig.ini.# That said, it is structured for ease-of-use, so it is not strictly# conformant to any of those existing configuration formats.# SUSHI will use id as both id and packageId in the IG unless a# specific packageId is also provided in this file.id:fhir.us.examplecanonical:http://hl7.org/fhir/us/exampleurl:http://hl7.org/fhir/us/example/ImplementationGuide/fhir.us.examplename:ExampleIGtitle:\"HL7 FHIR Implementation Guide: Example IG Release 1 - US Realm | STU1\"description:ExampleIGexercisesmanyofthefieldsinaSUSHIconfiguration.status:activelicense:CC0-1.0date:2020-02-26version:1.0.0# Although fhirVersions is 0..* in the ImplementationGuide resource# it can be a single item OR and array here (but so far SUSHI only# supports 4.0.1 anyway).fhirVersion:4.0.1# The following two lines correspond to items that used to be in# ig.ini but were moved to IG.definition.parameter. For# consistency within this file, the names are represented using# camelcase, but if authors use the formal parameter names, SUSHI# will recognize them as well. In either case, they'll be copied# to the IG JSON using the formal names.copyrightYear:2019+releaseLabel:STU1# The publisher can be a single item or a list, each with a name and# optional url and/or email. The first publisher's name will be used# as IG.publisher. The contact details and/or additional publishers# will be translated into IG.contact values.publisher:name:HL7FHIRManagementGroupurl:http://www.hl7.org/Special/committees/fhirmgemail:fmg@lists.HL7.org# Those who need more control or want to add additional details to the contact values can use# contact directly and follow the format outlined in the ImplementationGuide resource and# ContactDetail.contact:- name:BobSmithtelecom:- system:emailvalue:bobsmith@example.orguse:work# The jurisdiction can be a single item or a list. The FHIR Shorthand# code syntax can be used here.jurisdiction:urn:iso:std:iso:3166#US \"United States of America\"# The dependencies property corresponds to IG.dependsOn. The key is the# package id and the value is the version (or dev/current). For advanced# use cases, the value can be an object with keys for `uri` and `version`.dependencies:hl7.fhir.us.core:3.1.0hl7.fhir.us.mcode:id:mcodeuri:http://hl7.org/fhir/us/mcode/ImplementationGuide/hl7.fhir.us.mcodeversion:1.0.0# The global property corresponds to the IG.global property, but it# uses the type as the YAML key and the profile as its value. Since# FHIR does not explicitly disallow more than one profile per type,# neither do we; the value can be a single profile URL or an array# of profile URLs.global:Patient:http://example.org/fhir/StructureDefinition/my-patient-profileEncounter:http://example.org/fhir/StructureDefinition/my-encounter-profile# The resources property corresponds to IG.definition.resource.# SUSHI can auto-generate all of the resource entries based on# the FSH definitions and/or information in any user-provided# JSON or XML resource files. If the generated entries are not# sufficient or complete, however, the author can add entries# here. If the reference matches a generated entry, it will# replace the generated entry. If it doesn't match any generated# entries, it will be added to the generated entries. The format# follows IG.definition.resource with the following differences:# * use IG.definition.resource.reference.reference as the YAML key# * specify \"omit\" to omit a FSH-generated resource from the# resource list.# * groupingId can be used, but top-level groups syntax may be a# better option (see below).# The following are simple examples to demonstrate what this might# look like:resources:Patient/my-example-patient:name:MyExamplePatientdescription:AnexamplePatientexampleBoolean:truePatient/bad-example:omit# Groups can control certain aspects of the IG generation. The IG# documentation recommends that authors use the default groups that# are provided by the templating framework, but if authors want to# use their own instead, they can use the mechanism below. This will# create IG.definition.grouping entries and associate the individual# resource entries with the corresponding groupIds.groups:GroupA:name:GroupAdescription:TheAlphaGroupresources:- StructureDefinition/animal-patient- StructureDefinition/arm-procedureGroupB:name:GroupBdescription:TheBetaGroupresources:- StructureDefinition/bark-control- StructureDefinition/bee-sting# The pages property corresponds to IG.definition.page. SUSHI can# auto-generate the page list, but if the author includes pages in# this file, it is assumed that the author will fully manage the# pages section and SUSHI will not generate any page entries.# The page file name is used as the key. If title is not provided,# then the title will be generated from the file name. If a# generation value is not provided, it will be inferred from the# file name extension. Any subproperties that are valid filenames# with supported extensions (e.g., .md/.xml) will be treated as# sub-pages.pages:index.md:title:ExampleHomeimplementation.xml:examples.xml:title:ExamplesOverviewsimpleExamples.xml:complexExamples.xml:# The ImplementationGuide resource defines several other properties# not represented above. These properties can be used as-is and# should follow the format defined in ImplementationGuide:# * meta# * implicitRules# * language# * text# * contained# * extension# * modifierExtension# * experimental# * useContext# * copyright# * packageId# The menu property will be used to generate the input/menu.xml file.# The menu is represented as a simple structure where the YAML key# is the menu item name and the value is the URL. The IG publisher# currently only supports one level deep on sub-menus.# To provide a custom menu.xml file, do not include this property and# include a `menu.xml` file in input/includes.menu:Home:index.htmlArtifacts:Profiles:artifacts.html#2Extensions:artifacts.html#3Value Sets:artifacts.html#4Downloads:downloads.htmlHistory:http://hl7.org/fhir/us/example/history.html# The parameters property represents IG.definition.parameter. Rather# than a list of code/value pairs (as in the ImplementationGuide# resource), the code is the YAML key. If a parameter allows repeating# values, the value in the YAML should be a sequence/array. For a# partial list of allowed parameters see:# https://confluence.hl7.org/display/FHIR/Implementation+Guide+Parametersparameters:excludettl:truevalidation:[allow-any-extensions,no-broken-links]# The FSHOnly flag indicates if only FSH resources should be exported.# If set to true, no IG related content will be generated.# The default value for this property is false.FSHOnly:false# When set to true, the \"short\" and \"definition\" field on the root element of an Extension will# be set to the \"Title\" and \"Description\" of that Extension. Default is true.applyExtensionMetadataToRoot:false Download Exhaustive Configuration Example\n","excerpt":"SUSHI is configured by a single sushi-config.yaml file. This file is …","ref":"/docs/sushi/configuration/","title":"Configuration"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  This section several tutorials that will walk you through the process of using FSH to make a FHIR Implementation Guide.\n","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/tutorials/","title":"Tutorials"},{"body":"This tutorial will walk you through an example of using GoFSH to turn FHIR artifacts into FSH definitions. This tutorial assumes you have already installed GoFSH.\nStep 1: Download Sample FHIR Artifacts To start with some example FHIR artifacts,  download the GoFSH Tutorial and unzip it into a directory of your choice.\nAfter the file is unzipped, you should see two FHIR artifacts:\n StructureDefinition-mcode-genetic-specimen.json StructureDefinition-mcode-laterality.json  Step 2: Run GoFSH Now that you have GoFSH installed and sample FHIR artifacts, open up a command window, and navigate to the directory containing the artifacts you downloaded. Run GoFSH on those files by executing:\n gofsh .  Note The dot (.) represents “this directory,” the location of the files. You can also specify the location explicitly by replacing the dot with a directory path.  Running GoFSH will create a gofsh directory, and populate it with input/fsh, a directory containing several FSH files which define the original input files. If you open up profiles.fsh, you should see a FSH definition for a Profile called “GeneticSpecimen”, and if you open up extensions.fsh, you should see an Extension called “Laterality”.\nStep 3: Run SUSHI (Optional) Now that you have generated FSH definitions, you can run SUSHI on those definitions to recreate your original input to GoFSH. First, ensure you have SUSHI installed. Then, navigate the command line to the gofsh/ directory, and run:\n sushi . This command will run SUSHI on the contents of input/fsh, and generate the output of that FSH into a directory called fsh-generated/resources. You can then compare the output from running GoFSH and then SUSHI to the original StructureDefinition-mcode-genetic-specimen.json and StructureDefinition-mcode-laterality.json files.\nAlternatively, you can automatically run SUSHI on the output of GoFSH using the -f option. The following command:\n gofsh . -f will run SUSHI on the output of GoFSH, and generate a comparison file in gofsh/fshing-trip-comparison.html which displays differences between the original input, and the output of SUSHI.\n","excerpt":"This tutorial will walk you through an example of using GoFSH to turn …","ref":"/docs/tutorials/gofsh/","title":"GoFSH Tutorial"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  Note This documentation assumes you have a SUSHI-compliant project structure and configuration as discussed in the previous sections.  Running SUSHI SUSHI is executed from the command line. The general form of the SUSHI execution command is as follows:\n sushi {specification-directory} {options} where options include the following (in any order):\n-o, --out \u003cout\u003e the path to the output directory (default: ./build) -s, --snapshot generate snapshot in StructureDefinition output (default: false) -d, --debug output extra debugging information (default: false) -i, --init initialize a SUSHI project -v, --version output SUSHI version and implemented FSH specification version -h, --help output usage information  Tip If you run SUSHI from your FSH project directory, and accept the defaults, the command can be shortened to sushi .. NOTE: If your FSH project has a fsh subdirectory, SUSHI will default to fsh as the input location and fsh’s parent directory as the output location. This behavior is to support the IG Publisher integration.  Note By default, SUSHI only generates the profile differential, allowing the IG Publisher to create the profile snapshot. This is the approach recommended by HL7 FHIR leadership. If authors prefer, the -s option can be used to cause SUSHI to generate the snapshot without having to run the IG Publisher.  While SUSHI is running, it will print status messages as it processes your project files. When SUSHI has completed, you should receive a summary like the following:\n╔════════════════════════ SUSHI RESULTS ══════════════════════════╗ ║ ╭──────────┬────────────┬───────────┬─────────────┬───────────╮ ║ ║ │ Profiles │ Extensions │ ValueSets │ CodeSystems │ Instances │ ║ ║ ├──────────┼────────────┼───────────┼─────────────┼───────────┤ ║ ║ │ 1 │ 1 │ 1 │ 1 │ 1 │ ║ ║ ╰──────────┴────────────┴───────────┴─────────────┴───────────╯ ║ ║ ║ ║ See SUSHI-GENERATED-FILES.md for details on generated IG files. ║ ╠═════════════════════════════════════════════════════════════════╣ ║ O-fish-ally error free! 0 Errors 0 Warnings ║ ╚═════════════════════════════════════════════════════════════════╝ Error Messages In the process of developing your IG using FSH, you may encounter SUSHI error messages (written to the command console). Most error messages point to a specific line or lines in a .fsh file. If possible, SUSHI will continue, despite errors, to produce FHIR artifacts, but those artifacts may omit problematic rules. SUSHI should always exit gracefully. If SUSHI crashes, please report the issue using the SUSHI issue tracker.\nHere are some general tips for debugging:\n Parsing (syntax) errors should be fixed first. A single syntax error can ballooon into many other errors, so you should always eliminate syntax errors first. Syntax error messages may include extraneous input {x} expecting {y}, mismatched input {x} expecting {y} and no viable alternative at {x}. These messages indicate that the line in question is not a valid FSH statement. The order of keywords matters. The declarations must start with the type of item you are creating (e.g., Profile, Instance, ValueSet). The order of rules usually doesn’t matter, but there are exceptions. Slices and extensions must be created before they are constrained. Rules must contain valid paths. The No element found at path error means that although the overall grammar of the rule may be correct, SUSHI could not find the FHIR element you are referring to in the rule. Make sure there are no spelling errors, the element names in the path are correct, and you are using the path grammar correctly. The community can help. If you are getting an error you can’t resolve, you can ask for help on the #shorthand chat channel.  SUSHI Outputs Based on the inputs in FSH files, config.yaml, and the ig-data directory, SUSHI populates the output directory. For example, the customized-ig project from the Project Structure section would result in output like the following:\ncustomized-ig ├── fsh │ └── (fsh files) ├── ig.ini ├── input │ ├── ImplementationGuide-myIG.json │ ├── ignoreWarnings.txt │ ├── examples │ │ └── Patient-myPatient-example.json │ ├── extensions │ │ └── StructureDefinition-myExtension.json │ ├── images │ │ ├── myDocument.pdf │ │ ├── myGraphic.png │ │ └── mySpreadsheet.xlsx │ ├── includes │ │ └── menu.xml │ ├── pagecontent │ │ ├── index.md │ │ ├── mySecondPage.md │ │ ├── myThirdPage.md │ │ └── myFourthPage.md │ ├── profiles │ │ └── StructureDefinition-myProfile.json │ └── vocabulary │ ├── ValueSet-myValueSet.json │ └── CodeSystem-myCodeSystem.json └── package-list.json  Info SUSHI generates output into a directory called input, because it is generating input files for the IG Publisher. The IG Publisher requires this directory to be named input.  Note the following files and directories from the output:\n ig.ini: Copied from the fsh/ig-data directory, but can alternately be specified via the template property in fsh/config.yaml. input/ignoreWarnings.txt: Copied from the fsh/ig-data/input directory, but will be generated as a blank file if it isn’t found. input/examples*, input/extensions*, input/profiles*, input/vocabulary*: Generated from the definitions in the fsh/*.fsh files. input/images/*: Copied from the fsh/ig-data/input/images directory. input/includes/menu.xml: Copied from the fsh/ig-data/input/includes directory, but can alternately be specified via the menu property in fsh/config.yaml. input/pagecontent/*: Copied from the fsh/ig-data/input/pagecontent directory. Filenames with numeric prefixes will have the prefixes removed. package-list.json: Copied from the fsh/ig-data directory, but can alternately be specified via the history property in fsh/config.yaml.  Downloading the IG Publisher Note The following steps require the _updatePublisher.bat|sh and _genonce.bat|sh scripts in the output directory that SUSHI writes to. If these scripts are not present there, you will need to download them from the sample-ig project. The easiest way to do this is to download the sample-ig project, unzip it, and copy all of the .bat and .sh files to the directory that SUSHI writes to.  After running SUSHI, change directories to the output directory (if necessary). At the command prompt, enter:\n  _updatePublisher   ./_updatePublisher.sh This will download the latest version of the HL7 FHIR IG Publisher tool into the /build/input-cache directory. This step can be skipped if you already have the latest version of the IG Publisher tool in input-cache.\nTip If you are blocked by a firewall, or if for any reason _updatePublisher fails to execute, download the current IG Publisher jar file here. When the file has downloaded, move it into the input-cache directory (which you may need to create as a sibling to the input directory).  Running the IG Publisher Warning If you have never run the IG Publisher, you may need to install Jekyll first. See Installing the IG Publisher for details.  After the IG Publisher has been successfully downloaded, execute the following command to run it:\n  _genonce   ./_genonce.sh This will run the HL7 IG Publisher, which may take several minutes to complete. After the publisher is finished, open the file /output/index.html in a browser to see the resulting IG.\nTip When running SUSHI, the IG Publisher will look for an optional fsh.ini control file in the root directory of the project (the same directory that contains ig.ini). This file should have [FSH] on the first line, and can include a sushi-version property, used to specify which version of SUSHI the IG Publisher should use, and a timeout property, used to set a timeout for SUSHI (in seconds). The default timeout is 60 seconds. An example fsh.ini file is provided below.\n[FSH] sushi-version = 0.16.0 timeout = 120   ","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/sushi/running/","title":"Running SUSHI"},{"body":" Note This documentation assumes you have a SUSHI-compliant project structure and configuration as discussed in the previous sections.  Running SUSHI SUSHI is executed from the command line. The general form of the SUSHI execution command is as follows:\n sushi {specification-directory} {options} where options include the following (in any order):\n-o, --out \u003cout\u003e the path to the output folder -d, --debug output extra debugging information -p, --preprocessed output FSH produced by preprocessing steps -s, --snapshot generate snapshot in Structure Definition output (default: false) -i, --init initialize a SUSHI project -v, --version print SUSHI version -h, --help output usage information  Tip If you run SUSHI from your FSH project directory, and accept the defaults, the command can be shortened to sushi .  Note By default, SUSHI only generates the profile differential, allowing the IG Publisher to create the profile snapshot. This is the approach recommended by HL7 FHIR leadership. If authors prefer, the -s option can be used to cause SUSHI to generate the snapshot without having to run the IG Publisher.  While SUSHI is running, it will print status messages as it processes your project files. When SUSHI has completed, you should receive a summary like the following:\n╔════════════════════════ SUSHI RESULTS ══════════════════════════╗ ║ ╭──────────┬────────────┬───────────┬─────────────┬───────────╮ ║ ║ │ Profiles │ Extensions │ ValueSets │ CodeSystems │ Instances │ ║ ║ ├──────────┼────────────┼───────────┼─────────────┼───────────┤ ║ ║ │ 1 │ 1 │ 1 │ 1 │ 1 │ ║ ║ ╰──────────┴────────────┴───────────┴─────────────┴───────────╯ ║ ║ ║ ╠═════════════════════════════════════════════════════════════════╣ ║ O-fish-ally error free! 0 Errors 0 Warnings ║ ╚═════════════════════════════════════════════════════════════════╝ Error Messages In the process of developing your IG using FSH, you may encounter SUSHI error messages (written to the command console). Most error messages point to a specific line or lines in a .fsh file. If possible, SUSHI will continue, despite errors, to produce FHIR artifacts, but those artifacts may omit problematic rules. SUSHI should always exit gracefully. If SUSHI crashes, please report the issue using the SUSHI issue tracker.\nHere are some general tips for debugging:\n Parsing (syntax) errors should be fixed first. A single syntax error can ballooon into many other errors, so you should always eliminate syntax errors first. Syntax error messages may include extraneous input {x} expecting {y}, mismatched input {x} expecting {y} and no viable alternative at {x}. These messages indicate that the line in question is not a valid FSH statement. The order of keywords matters. The declarations must start with the type of item you are creating (e.g., Profile, Instance, ValueSet). The order of rules usually doesn’t matter, but there are exceptions. Slices and extensions must be created before they are constrained. Rules must contain valid paths. The No element found at path error means that although the overall grammar of the rule may be correct, SUSHI could not find the FHIR element you are referring to in the rule. Make sure there are no spelling errors, the element names in the path are correct, and you are using the path grammar correctly. The community can help. If you are getting an error you can’t resolve, you can ask for help on the #shorthand chat channel.  SUSHI Outputs Based on the inputs in FSH files, sushi-config.yaml, and the IG project directory, SUSHI populates the fsh-generated directory. For example, running SUSHI on the customized-ig project from the Project Structure section would add a fsh-generated folder as shown below:\ncustomized-ig ├── fsh-generated | └── resources | ├── CodeSystem-myCodeSystem.json | ├── Patient-myPatient-example.json | ├── StructureDefinition-myExtension.json | ├── StructureDefinition-myProfile.json | ├── ValueSet-myValueSet.json | └── ImplementationGuide-myIG.json ├── ig.ini ├── input | ├── fsh │ | └── (fsh files) │ ├── ignoreWarnings.txt │ ├── images │ │ ├── myDocument.pdf │ │ ├── myGraphic.png │ │ └── mySpreadsheet.xlsx │ ├── includes │ │ └── menu.xml │ ├── pagecontent │ │ ├── index.md │ │ ├── 2_mySecondPage.md │ │ ├── 3_myThirdPage.md │ │ └── 4_myFourthPage.md ├── package-list.json └── sushi-config.json SUSHI creates only the fsh-generated folder, but some of the files shown above are either processed by SUSHI to create the ImplementationGuide.json file, or can be generated by SUSHI if the author wishes. See the breakdown of files and directories below:\n fsh-generated*: Generated from the definitions in the input/fsh/*.fsh files. ig.ini: Specified by the author and unchanged by SUSHI. input/ignoreWarnings.txt: Specified by the author and unchanged by SUSHI. input/images/*: Specified by the author and unchanged by SUSHI. input/includes/menu.xml: Specified by the author and unchanged by SUSHI, but can alternately be specified via the menu property in sushi-config.yaml. If the menu configuration property is used, the output is generated to fsh-generated/includes/menu.xml. input/pagecontent/*: Specified by the author, numeric prefixes are used by SUSHI in generating the ImplementationGuide-myIG.json file. package-list.json: Specified by the author and unchanged by SUSHI.  Downloading the IG Publisher Scripts To run the IG Publisher, we recommend downloading the _updatePublisher.bat|sh and _genonce.bat|sh scripts provided by the sample-ig project. To get these scripts, download the sample-ig project, unzip it, and copy all of the .bat and .sh files to the directory above the fsh-generated directory (customized-ig in the example above).\nDownloading the IG Publisher After copying these, change directories in the command prompt to the directory above the fsh-generated directory. At the command prompt, enter:\n  _updatePublisher   ./_updatePublisher.sh This will download the latest version of the HL7 FHIR IG Publisher tool into the /input-cache directory. This step can be skipped if you already have the latest version of the IG Publisher tool in input-cache.\nTip If you are blocked by a firewall, or if for any reason _updatePublisher fails to execute, download the current IG Publisher jar file here. When the file has downloaded, move it into the input-cache directory (which you may need to create as a sibling to the input directory).  Running the IG Publisher Warning If you have never run the IG Publisher, you may need to install Jekyll first. See Installing the IG Publisher for details.  After the IG Publisher has been successfully downloaded, execute the following command to run it:\n  _genonce   ./_genonce.sh This will run the HL7 IG Publisher, which may take several minutes to complete. After the publisher is finished, open the file /output/index.html in a browser to see the resulting IG.\nTip When running SUSHI, the IG Publisher will look for an optional fsh.ini control file in the root directory of the project (the same directory that contains ig.ini). This file should have [FSH] on the first line, and can include a sushi-version property, used to specify which version of SUSHI the IG Publisher should use, and a timeout property, used to set a timeout for SUSHI (in seconds). The default timeout is 60 seconds. An example fsh.ini file is provided below.\n[FSH] sushi-version = 0.16.0 timeout = 120   Preprocessed FSH When running SUSHI, the -p or --preprocessed flag can be used to to create a _preprocessed folder in SUSHI’s output folder (customized-ig/_preprocessed in the example above). This folder will contain representations of the input FSH after several preprocessing steps have taken place. These steps include resolution of Alias values, insertion of RuleSet rules, and resolution of soft indexing. This is mainly provided as a debugging tool, for the author to verify that SUSHI is preprocessing the input FSH in an expected way, and to help trace errors in the output of SUSHI back to their source. For example, if the IG Publisher reports an error on element Bundle.entry[56].resource, it may be difficult to identify the problematic entry in your FSH source if you used soft-indexing. It is much easier, however, to identify the problematic element in the preprocessed FSH that contains explicit indices.\nThe example below shows a FSH snippet and a preprocessed version of that snippet. In this snippet, a Profile is defined using a RuleSet and an Alias, and below an Instance is defined which uses soft indexing.\nAlias: CAT = http://hl7.org/fhir/ValueSet/observation-category Profile: ObservationProfile Parent: Observation * insert Metadata * category from CAT (required) RuleSet: Metadata * ^version = \"1.2.3\" * ^publisher = \"Example publisher\" Instance: PatientInstance InstanceOf: Patient * name.given[+] = \"John\" * name.given[+] = \"Q\" The preprocessed version of the above FSH is shown below. The CAT alias has been resolved to its full URL, the rules contained in the RuleSet have been inserted onto the ObservationProfile, and the RuleSet itself has been removed, and the rules on the PatientInstance have been resolved to fully specified paths, which do not use soft indexing.\nAlias: CAT = http://hl7.org/fhir/ValueSet/observation-category // Originally defined on lines 3 - 6 Profile: ObservationProfile Parent: Observation Id: ObservationProfile * ^version = \"1.2.3\" * ^publisher = \"Example publisher\" * category from http://hl7.org/fhir/ValueSet/observation-category (required) // Originally defined on lines 12 - 15 Instance: PatientInstance InstanceOf: Patient Usage: #example * name.given[0] = \"John\" * name.given[1] = \"Q\"  Note Once you have finished reviewing your preprocessed FSH, we recommend deleting the _preprocessed folder to avoid potential confusion related to multiple versions of FSH files in your project. For this same reason, we do not recommend committing your preprocessed FSH to source control.  ","excerpt":" Note This documentation assumes you have a SUSHI-compliant project …","ref":"/docs/sushi/running/","title":"Running SUSHI"},{"body":"GoFSH exposes a fhirToFsh function that can be used to convert FHIR to FSH.\nSyntax fhirToFsh(fhir[, options]) Parameters fhir - An array of FHIR resources, represented either as strings or JSON.\noptions - An object which can have any combindation of the following attributes:\n dependencies - An array of strings used to specify dependencies required for processing the FHIR. Dependencies should use the format \u003cpackageId\u003e@\u003cversion\u003e (example: hl7.fhir.us.core@3.0.1). logLevel - A string that specifies what level of logging to use when processing FHIR. Options are silent, debug, info, warn, and error. style - A string representing how the returned output is styled. The options are:   string - The generated FSH will be returned in one single string. This is the default.\n  map - The generated FSH will be returned as an object. The attributes on the object are:\n aliases - A string containing all Alias definitions. profiles - A Map containing all Profile definitions as values. extensions - A Map containing all Extension definitions as values. codeSystems - A Map containing all CodeSystem definitions as values. valueSets - A Map containing all ValueSet definitions as values. instances - A Map containing all Instance definitions as values. invariants - A Map containing all Invariant definitions as values. mappings - A Map containing all Mapping definitions as values.  For each Map, the keys are the name of the FSH definition. For example, if the definition was:\nProfile: MyPatient Parent: Patient The key would be MyPatient.\n    Return Value An object with the following attributes:\n fsh - The generated FSH, styled according to the style parameter. configuration - An object representing the sushi-config.yaml file that would be generated if GoFSH was running in a command line interface. errors - An array of strings containing any errors detected during processing. warnings - An array of strings containing any warnings detected during processing.  Usage To use fhirToFsh, you must first install gofsh as a dependency of your project:\n npm install gofsh Once gofsh is installed as a dependency of your project, you can import and use this function as shown:\nimport { gofshClient } from 'gofsh'; // Example basic usage gofshClient.fhirToFsh(['Your FHIR here']); // Example usage with options gofshClient.fhirToFsh( ['Your FHIR here'], { dependencies: [\"hl7.fhir.us.mcode@1.0.0\"], style: \"map\", logLevel: \"silent\" }); ","excerpt":"GoFSH exposes a fhirToFsh function that can be used to convert FHIR to …","ref":"/docs/gofsh/api/","title":"API"},{"body":"SUSHI exposes a fshToFhir function that can be used to convert FSH strings to FHIR JSON.\nSyntax fshToFhir(fshString[, options]) Parameters fshString - A string containing FHIR Shorthand definitions.\noptions - An object which can have any combination of the following attributes:\n canonical - A string used to specify the canonical URL. version - A string used to specify the version. fhirVersion - A string used to specify the version of FHIR to use. Note that SUSHI only supports FHIR R4 and R5. dependencies - An array of objects used to specify dependencies required for processing the FSH. Each object should have a packageId and version, and optionally a uri. logLevel - A string that specifies what level of logging to use when processing FSH. Options are silent, debug, info, warn, and error.  See the configuration documentation for more information on canonical, version, fhirVersion, and dependencies. These properties correspond to the properties of the same name that are used in sushi-config.yaml.\nReturn Value An object with the following attributes:\n fhir - An array of FHIR definitions generated from the input FSH. errors - An array of strings containing any errors detected during processing. warnings - An array of strings containing any warnings detected during processing.  Usage To use fshToFhir, you must first install fsh-sushi as a dependency of your project:\n npm install fsh-sushi Once fsh-sushi is installed as a dependency of your project, you can import and use this function as shown:\nimport { sushiClient } from 'fsh-sushi'; // Example basic usage sushiClient.fshToFhir('Your FSH here'); // Example usage with options sushiClient.fshToFhir( 'Your FSH here', { canonical: 'http://example.com', version: '1.2.3', fhirVersion: '4.0.1', dependencies: [{ packageId: 'hl7.fhir.us.core', version: '3.1.0' }], logLevel: 'error' }); ","excerpt":"SUSHI exposes a fshToFhir function that can be used to convert FSH …","ref":"/docs/sushi/api/","title":"API"},{"body":"Migrating from pre-1.0.0 Projects The SUSHI project structure and configuration changed significantly between pre-1.0.0 versions of SUSHI and versions of SUSHI 1.0.0 or greater. This guide will assume you currently have a project structure similar to the customized ig shown in the project structure documentation for pre-1.0.0 versions of SUSHI.\nTo migrate your project, follow these steps:\n0 - Create a Backup Before beginning the migration process, make a copy of your entire project directory structure, and keep it in a safe place.\n1 - Delete SUSHI-Generated Files If you have previously used SUSHI, you have SUSHI-generated files that need to be cleaned up. If you use Git, you can remove all untracked files using the command:\n git clean -xfd Before executing this command, you can run git clean -xfdn to preview the list of files Git will remove. If it looks OK, then run the command above.\nIf you are not using Git, you can refer to ./SUSHI-GENERATED-FILES.md for a partial list of files to delete. (This list does not include generated profiles, value sets, extensions, and examples found in the ./input directory that should also be deleted.)\nKeep in mind that if you created FHIR artifacts NOT using SUSHI, those files must be retained. Typically, they will be found under the ./input directory.\n2 - Rearrange Directories Move the entire contents of ./fsh/ig-data directory to the top level (do not move the /ig-data directory, just its contents).\nNote If after the cleanup, you still have a top-level ./input directory, then merge the contents of ./fsh/ig-data/input into that directory (rather than replacing it).  Next, move the entire ./fsh directory into the ./input directory (resulting in a ./input/fsh directory).\nFinally, delete the ./input/fsh/ig-data directory (which should be empty).\nYour directory structure should now look something like this:\n. └── input │ ├── fsh │ ├── images │ └── pagecontent └── (other directories such as input-cache, output, temp, template) 3 - Adjust Page Names or Links SUSHI no longer removes numeric prefixes from the file names of pages. If you did not use numeric prefixes on page files you can skip to step 4. Otherwise, you will need to rename your page files or fix your existing links to these pages.\n3.1 Rename Page Files\nTo maintain the same page names and locations in your IG, remove the numeric prefixes from your page file names. For example, rename 3_downloads.md to downloads.md. Then add a pages property to sushi-config.yaml to specify the desired page order in the table of contents. For example:\npages:index.md:title:Homeconformance.md:title:Conformanceimplementation.md:title:Implementationdownloads.md:title:Downloads3.2 Fix Existing Links to Pages\nIf you want to continue specifying page order using numeric prefixes on file names instead, you will need to fix all existing links to include the numeric prefix. For example, the link\n[Downloads](downloads.html) (or \u003ca href=\"downloads.html\"\u003eDownloads\u003c/a\u003e) should become:\n[Downloads](3_downloads.html) (or \u003ca href=\"3_downloads.html\"\u003eDownloads\u003c/a\u003e) 4 - Move and Rename config.yaml Move the ./input/fsh/config.yaml file to the top-level folder, and rename it sushi-config.yaml.\n5 - Run SUSHI and Follow Instructions You can now run SUSHI 1.0. You may get further instructions in the form of error messages.\nNote Although SUSHI 2.0 is available for use, if you are migrating from a pre-1.0.0 version of SUSHI, we recommend first updating to the latest SUSHI 1.0 version of SUSHI (this is SUSHI 1.3.2 and can be installed via npm install -g fsh-sushi@1.3.2). After resolving all errors and warnings in that version, only then should you migrate to a SUSHI 2.0 release.  One error message concerns the template property in sushi-config.yaml. If you get that error, follow the instructions to remove that property from sushi-config.yaml and create an ./ig.ini file.\nWarning Carefully consider the contents of ig.ini. You must specify a template property based on fhir.base.template#current. Older templates will not work with SUSHI 1.0. Any of the following should work:\n template = fhir.base.template#current template = hl7.base.template#current template = hl7.fhir.template#current template = hl7.davinci.template#current template = hl7.cda.template#current  The ig property must point to an ImplementationGuide resource. If SUSHI is generating your ImplementationGuide resource, it will be generated to fsh-generated/resources/ImplementationGuide-{ig-id}.json.\n Another error message you might receive concerns the history property in sushi-config.yaml. If you get that message, remove that property and create the package-list.json file as instructed.\nWhen you get a clean build with SUSHI, try running the IG Publisher using your customary method (e.g., using the _genonce script). This will verify that all files needed by the IG Publisher are in the right place.\n6 - Update .gitignore If you are using Git for version control, update your .gitignore file.\n  Remove entries for ig.ini, package-list.json, and the input directory, if present. These two files and the entire ./input folder should now be under source code control.\n  Add ./fsh-generated to .gitignore. This is where SUSHI 1.0 puts all generated files.\n  Here is a typical .gitignore suitable for SUSHI 1.0:\n.DS_Store Thumbs.db /fsh-generated /input-cache /output /template /temp Troubleshooting Some users may experience one of these issues when running the IG Publisher on their migrated project:\n The IG publisher reports No Source directories to scan found The published IG does not include any of the resources from fsh-generated  This usually means that the IG Publisher is not using the correct template. First, check to ensure your your ig.ini specifies the #current version of one of the supported templates (or a template that extends one of the supported templates).\nIf you’ve confirmed you are using a #current version of a supported template, then the IG Publisher likely failed to download the updated template in your FHIR cache. This may be due to corporate firewalls, network issues, or restrictive file permissions in your FHIR cache. Sometimes, you can resolve this issue by deleting the base template from your FHIR cache:\n  C:\\Users\\{user}\\.fhir\\packages\\fhir.base.template#current\n  /Users/{user}/.fhir/packages/fhir.base.template#current\nsubstituting {user} with your username on your operating system.\nNote If there is a general problem with downloading the template (as opposed to overwriting it), deleting the template will not fix it. Instead the problem will just become more obvious. If this is the case, you may need to disconnect from your VPN (if applicable) and try again or contact your network administrator for assistance.\nFor this reason, you may choose to temporarily move your fhir.base.template#current folder rather than deleting it. This way, if the new template still fails to download, you can move the old template back and continue using it for other IGs (for which the new template may not be necessary).\n ","excerpt":"Migrating from pre-1.0.0 Projects The SUSHI project structure and …","ref":"/docs/sushi/migration/","title":"Migrating from Older Versions"},{"body":"body {background-color: #fcac98;} Warning This documentation is for Legacy versions of SUSHI (pre-1.0.0). Head to the Documentation tab for documentation on the current version of SUSHI.  Here you will find documentation on how to get started using FSH to create Implementation Guides. Head to Introduction for some background information on FSH and FHIR. If you’re ready to start writing some FSH, go to SUSHI to learn about the SUSHI compiler for FSH. If you want to dive right into creating an Implementation Guide, check out the Tutorials for full instructions on making an Implementation Guide using FSH and SUSHI.\n","excerpt":"body {background-color: #fcac98;} Warning This documentation is for …","ref":"/docs/docs-legacy/","title":"Legacy Documentation [Pre-1.0]"},{"body":"","excerpt":"","ref":"/community/","title":"Community"},{"body":" Note Documentation of the FHIR Shorthand language standard is found on the official HL7 site. The Language Reference has details on FSH grammar. This site covers SUSHI and GoFSH and creation of FHIR Implementation Guides using these tools.  What is SUSHI? SUSHI (SUSHI Unshortens ShortHand Inputs) is a FSH compiler. SUSHI converts FSH language to FHIR artifacts. SUSHI can run in stand-alone mode or as part of the HL7 IG Publisher.\nWhat is GoFSH? GoFSH is a converter that takes FHIR artifacts (e.g., profiles, extensions, value sets, instances) and produces equivalent FSH. GoFSH is essentially the opposite of SUSHI. GoFSH helps you transition to FSH if you have an existing Implementation Guide produced by other methods.\nNavigating the Documentation   Head to Introduction for some background information on FSH and FHIR.\n  If you want to dive right into creating an Implementation Guide, check out the Tutorials for hands-on exercises.\n  If you’re ready to start writing some FSH, but first want an overview, consult the latest presentations in Downloads.\n  Go to SUSHI to learn about the SUSHI compiler for FSH.\n  If you already have an Implementation Guide and want to switch over to FSH, consult the GoFSH documentation.\n  If you are still using a pre-release version of SUSHI (version 0.16 or earlier), you should migrate to the latest released version. Documentation for pre-release versions of SUSHI is preserved here.\n  If you are looking for specific information, you can search the documentation using the search box in the upper right corner.\n  Warning Search will return hits in both the current and legacy (pre-1.0) documentation. Legacy documentation is flagged by a warning on the page and a salmon-colored background.  ","excerpt":" Note Documentation of the FHIR Shorthand language standard is found …","ref":"/docs/","title":"Documentation"},{"body":"  Downloads Various presentations and software you can download.\nFHIR Shorthand Quick Reference Sheet A “cheat sheet” with the entire FSH Grammar at a glance\nThe Full FHIR Shorthand Specification A zip file containing the entire formal specification (Standard for Trial Use 1)\nSUSHI Software  Open a command window At the prompt, type npm install -g fsh-sushi  For full instructions and prerequisites, see SUSHI Installation\nGoFSH Software  Open a command window At the prompt, type npm install -g gofsh  For full instructions and prerequisites, see GoFSH Installation\nPresentations from FHIR DevDays, November 2020  Introduction to FHIR Shorthand Let’s Build with FHIR Shorthand  Tutorials from the HL7 FHIR Connectathon, September 2020  Introduction to FHIR Shorthand Advanced FHIR Shorthand Wicked FHIR Shorthand (Version 2 Plans) FSHing Equipment (Overview of FSH Tools)     ","excerpt":"  Downloads Various presentations and software you can download.\nFHIR …","ref":"/downloads/","title":"Downloads"},{"body":"  #td-cover-block-0 { background-image: url(/featured_background_hu54f3643f12bd21df874b3e28ba2f51ba_336333_960x540_fill_catmullrom_top_2.png); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured_background_hu54f3643f12bd21df874b3e28ba2f51ba_336333_1920x1080_fill_catmullrom_top_2.png); } }  Welcome to FSH School Quick Start   Read the Docs   Play with FSH   Who's on Board?   The place to learn and try FHIR Shorthand\n\n        FHIR Shorthand (FSH) is a domain-specific language for defining the contents of FHIR Resources and Implementation Guides. Explore FSH School to get the knowledge you need to get started using FSH.       Declarative FSH allows you to define FHIR profiles in a simple, declarative language. No more large JSON files or spreadsheets, just human-readable text files which compile to the FHIR artifacts you need.\n   Fast and Agile FSH is amazingly compact, fun to write, and painless to modify when you need to make changes. Take a look at the official FSH specification for more information about how FSH can be used to profile FHIR.\n   Source control ready Unlike other tools for profiling FHIR, FSH works seamlessly with source control tools like GitHub. Maintain a history of changes, track contributions, and maintain agility by using FSH with source control.\n     “FSH has legs.”\n - Grahame Grieve, FHIR Product Director\n “An immensely useful project.”\n - Richard Kavanagh, Product Manager for Interoperability, Graphnet Health, Board Member HL7 UK and INTEROPen\n “The ability to create implementation guides, value sets, code systems, any sample resource you might ever want in this simple language is simply fantastic.”\n - Keith Boone, Informatics Adept at Audacious Inquiry\n “FSH is a joy.”\n - David Hay, “Hay on FHIR” blog\n    ","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/","title":"FSH School"},{"body":"\nQuick Start Get started producing FHIR Profiles and Implementation Guides in no time.\n    FHIR Shorthand (FSH) is a domain-specific language for defining the contents of FHIR Implementation Guides (IG). FSH can be created and updated using any text editor. Because it is text, it enables distributed, team-based development using source code control tools such as GitHub.\nHere are three ways to get started:\n1. Do the Tutorials The easiest way to get familiar with FSH is through the hands-on tutorials. The tutorials will show you the end-to-end process of creating an Implementation Guide (IG) using FSH and SUSHI (the FSH compiler).\n2. Start a Project from Scratch If you are starting a brand-new project, follow these steps:\n  Install SUSHI.\n  Set up the directory structure for your project.\n  Create a sushi-config.yaml file\n  Create FSH files containing your content.\n  Run SUSHI or the IG Publisher tool to create your FHIR artifacts and Implementation Guide.\n  3. Transform an Existing Implementation Guide Using GoFSH, you can turn an existing FHIR Implementation Guide into a FSH project automatically. GoFSH instantly translates your StructureDefinitions, value sets, and examples into FHIR Shorthand.\n   ","excerpt":"\nQuick Start Get started producing FHIR Profiles and Implementation …","ref":"/quickstart/","title":"Quick Start"},{"body":"","excerpt":"","ref":"/search/","title":"Search Results"}]